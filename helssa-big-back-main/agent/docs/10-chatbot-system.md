# ğŸ¤– Ú†Øªâ€ŒØ¨Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ HELSSA

## ğŸ“‹ ÙÙ‡Ø±Ø³Øª Ù…Ø·Ø§Ù„Ø¨

- [Ù…Ø¹Ø±ÙÛŒ Ú†Øªâ€ŒØ¨Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ](## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ú†Øªâ€ŒØ¨Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ)
- [Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ú†Øª](## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ú†Øª)
- [Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡](## ğŸ“Š Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡)
- [Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§](## ğŸ“ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§)
- [Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ú©Ø§Ù„Ù…Ø§Øª](## ğŸ“ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ú©Ø§Ù„Ù…Ø§Øª)
- [Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„](## ğŸ“ Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„)
- [Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø§ Ù¾Ø²Ø´Ú©](## ğŸ“ Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø§ Ù¾Ø²Ø´Ú©)
- [Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú†Øª](## ğŸ“ Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú†Øª)

---

## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ú†Øªâ€ŒØ¨Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ

Ú†Øªâ€ŒØ¨Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ HELSSA ÛŒÚ© Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ 24/7 Ø§Ø³Øª Ú©Ù‡ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² GPT-4 Ùˆ Ø¯Ø§Ù†Ø´ Ù¾Ø²Ø´Ú©ÛŒ ØªØ®ØµØµÛŒØŒ Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ø¨ÛŒÙ…Ø§Ø±Ø§Ù† Ù¾Ø§Ø³Ø® Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø§Ø±Ø§Ø¦Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.

### ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

- ğŸ’¬ **Ù¾Ø§Ø³Ø®â€ŒÚ¯ÙˆÛŒÛŒ 24/7** Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ
- ğŸ§  **Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡** Ø¨Ø§ GPT-4
- ğŸŒ **Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ú†Ù†Ø¯Ø²Ø¨Ø§Ù†Ù‡** (ÙØ§Ø±Ø³ÛŒØŒ Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒØŒ Ø¹Ø±Ø¨ÛŒ)
- ğŸ“Š **ØªØ­Ù„ÛŒÙ„ Ø¹Ù„Ø§Ø¦Ù…** Ùˆ Ø§Ø±Ø§Ø¦Ù‡ ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§
- ğŸš¨ **ØªØ´Ø®ÛŒØµ Ù…ÙˆØ§Ø±Ø¯ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ÛŒ** Ùˆ Ø§Ø±Ø¬Ø§Ø¹ ÙÙˆØ±ÛŒ
- ğŸ“ **Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ú©Ø§Ù„Ù…Ø§Øª** Ø¨Ø±Ø§ÛŒ Ù¾Ø²Ø´Ú©
- ğŸ”— **Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ** Ø¨Ø§ Ù¾Ø²Ø´Ú© Ù…Ø¹Ø§Ù„Ø¬
- ğŸ“± **Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ** Ø³Ø§Ø¯Ù‡ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ù¾Ø³Ù†Ø¯

## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ú†Øª

```mermaid
graph TB
    subgraph "User Interface"
        WEB[Web Chat Widget]
        MOB[Mobile App Chat]
        VOICE[Voice Interface]
    end
    
    subgraph "Chat Processing Layer"
        GW[WebSocket Gateway]
        CM[Chat Manager]
        QP[Query Processor]
        EC[Emergency Classifier]
    end
    
    subgraph "AI Services"
        GPT[GPT-4 Service]
        MED[Medical Knowledge Base]
        SENT[Sentiment Analyzer]
        SUM[Summarizer]
    end
    
    subgraph "Data Management"
        SESS[Session Manager]
        HIST[History Manager]
        SHARE[Share Manager]
    end
    
    subgraph "Storage"
        DB[(Chat Database)]
        REDIS[(Redis Cache)]
        VECTOR[(Vector DB)]
    end
    
    WEB --> GW
    MOB --> GW
    VOICE --> GW
    
    GW --> CM
    CM --> QP
    QP --> EC
    
    QP --> GPT
    GPT --> MED
    CM --> SENT
    
    CM --> SESS
    SESS --> HIST
    HIST --> SHARE
    
    All --> DB
    SESS --> REDIS
    MED --> VECTOR
```

### Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡

```python
chatbot/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ chat_session.py         # Ù…Ø¯Ù„ Ø¬Ù„Ø³Ù‡ Ú†Øª
â”‚   â”œâ”€â”€ chat_message.py         # Ù…Ø¯Ù„ Ù¾ÛŒØ§Ù…
â”‚   â”œâ”€â”€ chat_summary.py         # Ù…Ø¯Ù„ Ø®Ù„Ø§ØµÙ‡
â”‚   â””â”€â”€ shared_chat.py          # Ù…Ø¯Ù„ Ø§Ø´ØªØ±Ø§Ú©
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ chat_service.py         # Ø³Ø±ÙˆÛŒØ³ Ø§ØµÙ„ÛŒ Ú†Øª
â”‚   â”œâ”€â”€ query_processor.py      # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙˆØ§Ù„Ø§Øª
â”‚   â”œâ”€â”€ medical_advisor.py      # Ù…Ø´Ø§ÙˆØ± Ù¾Ø²Ø´Ú©ÛŒ
â”‚   â”œâ”€â”€ emergency_detector.py   # ØªØ´Ø®ÛŒØµ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³
â”‚   â”œâ”€â”€ summarizer.py           # Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²
â”‚   â””â”€â”€ share_service.py        # Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ
â”œâ”€â”€ consumers/
â”‚   â”œâ”€â”€ chat_consumer.py        # WebSocket consumer
â”‚   â””â”€â”€ voice_consumer.py       # Voice chat consumer
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ serializers.py
â”‚   â”œâ”€â”€ views.py
â”‚   â””â”€â”€ permissions.py
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ medical_prompts.py      # Ù¾Ø±Ø§Ù…Ù¾Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ
â”‚   â”œâ”€â”€ emergency_prompts.py    # Ù¾Ø±Ø§Ù…Ù¾Øªâ€ŒÙ‡Ø§ÛŒ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³
â”‚   â””â”€â”€ summary_prompts.py      # Ù¾Ø±Ø§Ù…Ù¾Øªâ€ŒÙ‡Ø§ÛŒ Ø®Ù„Ø§ØµÙ‡
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ validators.py           # Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ
â”‚   â”œâ”€â”€ formatters.py           # ÙØ±Ù…Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§
â”‚   â””â”€â”€ analytics.py            # ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±
â””â”€â”€ tasks.py                     # Celery tasks
```

## ğŸ“Š Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡

### Chat Session Model

```python
# chatbot/models/chat_session.py
from django.db import models
import uuid
from datetime import timedelta

class ChatSession(models.Model):
    """Ù…Ø¯Ù„ Ø¬Ù„Ø³Ù‡ Ú†Øª Ø¨Ø§ Ø¨Ø§Øª"""
    
    SESSION_STATUS = [
        ('active', 'ÙØ¹Ø§Ù„'),
        ('idle', 'ØºÛŒØ±ÙØ¹Ø§Ù„'),
        ('closed', 'Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡'),
        ('shared', 'Ø§Ø´ØªØ±Ø§Ú© Ú¯Ø°Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.ForeignKey(
        'unified_auth.UnifiedUser',
        on_delete=models.CASCADE,
        related_name='chat_sessions'
    )
    
    # ÙˆØ¶Ø¹ÛŒØª Ø¬Ù„Ø³Ù‡
    status = models.CharField(
        max_length=20,
        choices=SESSION_STATUS,
        default='active'
    )
    title = models.CharField(
        max_length=200,
        null=True,
        blank=True,
        help_text="Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ¯Ú©Ø§Ø± Ø¬Ù„Ø³Ù‡"
    )
    
    # Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ
    started_at = models.DateTimeField(auto_now_add=True)
    last_activity = models.DateTimeField(auto_now=True)
    closed_at = models.DateTimeField(null=True, blank=True)
    
    # ØªØ­Ù„ÛŒÙ„ Ø¬Ù„Ø³Ù‡
    message_count = models.IntegerField(default=0)
    ai_tokens_used = models.IntegerField(default=0)
    user_satisfaction = models.IntegerField(
        null=True,
        blank=True,
        help_text="Ø±Ø¶Ø§ÛŒØª Ú©Ø§Ø±Ø¨Ø± 1-5"
    )
    
    # Ø¹Ù„Ø§Ø¦Ù… Ùˆ Ù†Ú¯Ø±Ø§Ù†ÛŒâ€ŒÙ‡Ø§
    identified_symptoms = models.JSONField(
        default=list,
        help_text="Ø¹Ù„Ø§Ø¦Ù… Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡"
    )
    urgency_level = models.IntegerField(
        default=0,
        help_text="Ø³Ø·Ø­ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ 0-10"
    )
    recommended_actions = models.JSONField(
        default=list,
        help_text="Ø§Ù‚Ø¯Ø§Ù…Ø§Øª ØªÙˆØµÛŒÙ‡ Ø´Ø¯Ù‡"
    )
    
    # Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ
    is_shared = models.BooleanField(default=False)
    share_token = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        unique=True
    )
    shared_with = models.ManyToManyField(
        'unified_auth.UnifiedUser',
        related_name='shared_chats',
        blank=True
    )
    
    # metadata
    metadata = models.JSONField(default=dict)
    
    class Meta:
        db_table = 'chat_sessions'
        indexes = [
            models.Index(fields=['user', 'status', '-started_at']),
            models.Index(fields=['share_token']),
        ]
        ordering = ['-started_at']
        
    @property
    def duration(self) -> timedelta:
        """Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¬Ù„Ø³Ù‡"""
        if self.closed_at:
            return self.closed_at - self.started_at
        return timezone.now() - self.started_at
        
    @property
    def is_idle(self) -> bool:
        """Ø¢ÛŒØ§ Ø¬Ù„Ø³Ù‡ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª"""
        return (timezone.now() - self.last_activity).total_seconds() > 1800  # 30 Ø¯Ù‚ÛŒÙ‚Ù‡
```

### Chat Message Model

```python
# chatbot/models/chat_message.py

class ChatMessage(models.Model):
    """Ù…Ø¯Ù„ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ú†Øª"""
    
    MESSAGE_TYPES = [
        ('text', 'Ù…ØªÙ†'),
        ('voice', 'ØµÙˆØªÛŒ'),
        ('image', 'ØªØµÙˆÛŒØ±'),
        ('file', 'ÙØ§ÛŒÙ„'),
        ('system', 'Ø³ÛŒØ³ØªÙ…'),
    ]
    
    SENDER_TYPES = [
        ('user', 'Ú©Ø§Ø±Ø¨Ø±'),
        ('bot', 'Ø±Ø¨Ø§Øª'),
        ('system', 'Ø³ÛŒØ³ØªÙ…'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    session = models.ForeignKey(
        ChatSession,
        on_delete=models.CASCADE,
        related_name='messages'
    )
    
    # Ù…Ø­ØªÙˆØ§ÛŒ Ù¾ÛŒØ§Ù…
    content = models.TextField()
    type = models.CharField(
        max_length=10,
        choices=MESSAGE_TYPES,
        default='text'
    )
    sender = models.CharField(
        max_length=10,
        choices=SENDER_TYPES
    )
    
    # Ù¾ÛŒØ§Ù… ØµÙˆØªÛŒ/ØªØµÙˆÛŒØ±ÛŒ
    media_url = models.URLField(
        null=True,
        blank=True,
        help_text="Ø¢Ø¯Ø±Ø³ ÙØ§ÛŒÙ„ media"
    )
    media_duration = models.IntegerField(
        null=True,
        blank=True,
        help_text="Ù…Ø¯Øª Ø²Ù…Ø§Ù† ØµÙˆØª Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡"
    )
    
    # ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ§Ù…
    sentiment = models.CharField(
        max_length=20,
        null=True,
        blank=True,
        choices=[
            ('positive', 'Ù…Ø«Ø¨Øª'),
            ('neutral', 'Ø®Ù†Ø«ÛŒ'),
            ('negative', 'Ù…Ù†ÙÛŒ'),
            ('worried', 'Ù†Ú¯Ø±Ø§Ù†'),
            ('emergency', 'Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ÛŒ'),
        ]
    )
    detected_entities = models.JSONField(
        default=dict,
        help_text="Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡"
    )
    
    # Ù¾Ø§Ø³Ø® AI
    ai_confidence = models.FloatField(
        null=True,
        blank=True,
        help_text="Ø§Ø·Ù…ÛŒÙ†Ø§Ù† AI Ø§Ø² Ù¾Ø§Ø³Ø®"
    )
    ai_model = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        default='gpt-4'
    )
    tokens_used = models.IntegerField(
        default=0,
        help_text="ØªØ¹Ø¯Ø§Ø¯ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ Ù…ØµØ±ÙÛŒ"
    )
    
    # Ø§Ø±Ø¬Ø§Ø¹Ø§Øª
    references = models.JSONField(
        default=list,
        help_text="Ù…Ù†Ø§Ø¨Ø¹ Ùˆ Ø§Ø±Ø¬Ø§Ø¹Ø§Øª"
    )
    suggested_actions = models.JSONField(
        default=list,
        help_text="Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ"
    )
    
    # Ø²Ù…Ø§Ù†
    created_at = models.DateTimeField(auto_now_add=True)
    edited_at = models.DateTimeField(null=True, blank=True)
    
    # ÙˆØ§Ú©Ù†Ø´â€ŒÙ‡Ø§
    is_helpful = models.BooleanField(
        null=True,
        blank=True,
        help_text="Ø¢ÛŒØ§ Ù¾Ø§Ø³Ø® Ù…ÙÛŒØ¯ Ø¨ÙˆØ¯"
    )
    user_feedback = models.TextField(
        null=True,
        blank=True
    )
    
    class Meta:
        db_table = 'chat_messages'
        ordering = ['created_at']
        indexes = [
            models.Index(fields=['session', 'created_at']),
            models.Index(fields=['sender', 'type']),
        ]
```

### Chat Summary Model

```python
# chatbot/models/chat_summary.py

class ChatSummary(models.Model):
    """Ù…Ø¯Ù„ Ø®Ù„Ø§ØµÙ‡ Ù…Ú©Ø§Ù„Ù…Ø§Øª"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    session = models.OneToOneField(
        ChatSession,
        on_delete=models.CASCADE,
        related_name='summary'
    )
    
    # Ø®Ù„Ø§ØµÙ‡â€ŒÙ‡Ø§
    brief_summary = models.TextField(
        help_text="Ø®Ù„Ø§ØµÙ‡ Ú©ÙˆØªØ§Ù‡ (2-3 Ø¬Ù…Ù„Ù‡)"
    )
    detailed_summary = models.TextField(
        help_text="Ø®Ù„Ø§ØµÙ‡ ØªÙØµÛŒÙ„ÛŒ"
    )
    medical_summary = models.TextField(
        help_text="Ø®Ù„Ø§ØµÙ‡ Ù¾Ø²Ø´Ú©ÛŒ ØªØ®ØµØµÛŒ"
    )
    
    # Ù†Ú©Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ
    key_symptoms = models.JSONField(
        default=list,
        help_text="Ø¹Ù„Ø§Ø¦Ù… Ú©Ù„ÛŒØ¯ÛŒ"
    )
    key_concerns = models.JSONField(
        default=list,
        help_text="Ù†Ú¯Ø±Ø§Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ"
    )
    medical_history_mentioned = models.JSONField(
        default=dict,
        help_text="Ø³ÙˆØ§Ø¨Ù‚ Ù¾Ø²Ø´Ú©ÛŒ Ø°Ú©Ø± Ø´Ø¯Ù‡"
    )
    
    # ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§
    bot_recommendations = models.JSONField(
        default=list,
        help_text="ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡"
    )
    follow_up_needed = models.BooleanField(
        default=False,
        help_text="Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ"
    )
    referral_suggested = models.JSONField(
        null=True,
        blank=True,
        help_text="Ø§Ø±Ø¬Ø§Ø¹ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ"
    )
    
    # ØªØ­Ù„ÛŒÙ„
    overall_sentiment = models.CharField(
        max_length=20,
        choices=[
            ('positive', 'Ù…Ø«Ø¨Øª'),
            ('neutral', 'Ø®Ù†Ø«ÛŒ'),
            ('negative', 'Ù…Ù†ÙÛŒ'),
            ('concerned', 'Ù†Ú¯Ø±Ø§Ù†'),
            ('urgent', 'ÙÙˆØ±ÛŒ'),
        ]
    )
    urgency_score = models.IntegerField(
        default=0,
        help_text="Ø§Ù…ØªÛŒØ§Ø² ÙÙˆØ±ÛŒØª 0-100"
    )
    
    # ØªÙˆÙ„ÛŒØ¯
    generated_at = models.DateTimeField(auto_now_add=True)
    generated_by = models.CharField(
        max_length=50,
        default='ai',
        choices=[
            ('ai', 'Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ'),
            ('manual', 'Ø¯Ø³ØªÛŒ'),
            ('hybrid', 'ØªØ±Ú©ÛŒØ¨ÛŒ'),
        ]
    )
    
    class Meta:
        db_table = 'chat_summaries'
```

## ğŸ’¬ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§

### Chat Service

```python
# chatbot/services/chat_service.py
from typing import Dict, Optional, List
import asyncio

class MedicalChatService:
    """Ø³Ø±ÙˆÛŒØ³ Ø§ØµÙ„ÛŒ Ú†Øª Ù¾Ø²Ø´Ú©ÛŒ"""
    
    def __init__(self):
        self.query_processor = QueryProcessor()
        self.medical_advisor = MedicalAdvisor()
        self.emergency_detector = EmergencyDetector()
        self.sentiment_analyzer = SentimentAnalyzer()
        self.session_manager = SessionManager()
        
    async def process_message(
        self,
        user_id: str,
        message: str,
        session_id: Optional[str] = None,
        message_type: str = 'text',
        media_url: Optional[str] = None
    ) -> Dict:
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù… Ú©Ø§Ø±Ø¨Ø±"""
        
        # Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ù„Ø³Ù‡
        session = await self.session_manager.get_or_create_session(
            user_id, session_id
        )
        
        # Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ§Ù… Ú©Ø§Ø±Ø¨Ø±
        user_message = await self._save_user_message(
            session, message, message_type, media_url
        )
        
        # ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª
        sentiment = await self.sentiment_analyzer.analyze(message)
        user_message.sentiment = sentiment['sentiment']
        await user_message.save()
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³
        emergency_check = await self.emergency_detector.check(message)
        if emergency_check['is_emergency']:
            return await self._handle_emergency(
                session, user_message, emergency_check
            )
            
        # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙˆØ§Ù„ Ù¾Ø²Ø´Ú©ÛŒ
        query_result = await self.query_processor.process(
            message,
            session_context=await self._get_session_context(session)
        )
        
        # ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø®
        response = await self.medical_advisor.generate_response(
            query=query_result,
            user_profile=await self._get_user_profile(user_id),
            session_history=await self._get_recent_messages(session, 10)
        )
        
        # Ø°Ø®ÛŒØ±Ù‡ Ù¾Ø§Ø³Ø® Ø¨Ø§Øª
        bot_message = await self._save_bot_message(
            session, response
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¬Ù„Ø³Ù‡
        await self._update_session_analytics(session, user_message, bot_message)
        
        return {
            'session_id': str(session.id),
            'message_id': str(bot_message.id),
            'response': response['content'],
            'suggestions': response.get('suggestions', []),
            'references': response.get('references', []),
            'urgency_level': session.urgency_level,
            'follow_up_needed': response.get('follow_up_needed', False)
        }
        
    async def _handle_emergency(
        self,
        session: ChatSession,
        user_message: ChatMessage,
        emergency_info: Dict
    ) -> Dict:
        """Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ§Ø±Ø¯ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ÛŒ"""
        
        # ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø® Ø§ÙˆØ±Ú˜Ø§Ù†Ø³ÛŒ
        emergency_response = self._generate_emergency_response(
            emergency_info['type'],
            emergency_info['severity']
        )
        
        # Ø°Ø®ÛŒØ±Ù‡ Ù¾Ø§Ø³Ø®
        bot_message = await self._save_bot_message(
            session,
            {
                'content': emergency_response['message'],
                'is_emergency': True,
                'emergency_type': emergency_info['type']
            }
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¬Ù„Ø³Ù‡
        session.urgency_level = 10
        session.status = 'emergency'
        await session.save()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        await self._send_emergency_notification(
            session.user,
            emergency_info
        )
        
        return {
            'session_id': str(session.id),
            'message_id': str(bot_message.id),
            'response': emergency_response['message'],
            'emergency': True,
            'emergency_actions': emergency_response['actions'],
            'emergency_contacts': emergency_response['contacts']
        }
        
    async def _get_session_context(self, session: ChatSession) -> Dict:
        """Ø¯Ø±ÛŒØ§ÙØª context Ø¬Ù„Ø³Ù‡"""
        
        # Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
        recent_messages = await ChatMessage.objects.filter(
            session=session
        ).order_by('-created_at')[:20]
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù‡Ù…
        context = {
            'session_id': str(session.id),
            'duration': session.duration.total_seconds() / 60,
            'message_count': session.message_count,
            'identified_symptoms': session.identified_symptoms,
            'conversation_history': [
                {
                    'sender': msg.sender,
                    'content': msg.content,
                    'entities': msg.detected_entities
                }
                for msg in reversed(recent_messages)
            ]
        }
        
        return context
```

### Query Processor

```python
# chatbot/services/query_processor.py

class QueryProcessor:
    """Ù¾Ø±Ø¯Ø§Ø²Ø´Ú¯Ø± Ø³ÙˆØ§Ù„Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ"""
    
    def __init__(self):
        self.nlp_service = MedicalNLPService()
        self.entity_extractor = MedicalEntityExtractor()
        self.intent_classifier = IntentClassifier()
        
    async def process(
        self,
        query: str,
        session_context: Optional[Dict] = None
    ) -> Dict:
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¬Ø§Ù…Ø¹ Ø³ÙˆØ§Ù„"""
        
        # Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…ØªÙ†
        normalized_query = await self._normalize_text(query)
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§
        entities = await self.entity_extractor.extract(normalized_query)
        
        # ØªØ´Ø®ÛŒØµ Ù‚ØµØ¯
        intent = await self.intent_classifier.classify(
            normalized_query,
            entities,
            session_context
        )
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒØ´ØªØ±
        missing_info = await self._check_missing_information(
            intent, entities
        )
        
        # Ø³Ø§Ø®Øª query structure
        processed_query = {
            'original': query,
            'normalized': normalized_query,
            'intent': intent,
            'entities': entities,
            'missing_info': missing_info,
            'context': session_context,
            'requires_clarification': len(missing_info) > 0
        }
        
        return processed_query
        
    async def _normalize_text(self, text: str) -> str:
        """Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…ØªÙ† ÙØ§Ø±Ø³ÛŒ"""
        
        # Ø­Ø°Ù Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # ØªØµØ­ÛŒØ­ Ø§Ù…Ù„Ø§ÛŒÛŒ Ø±Ø§ÛŒØ¬
        corrections = {
            'Ø¯ÙˆØ§': 'Ø¯Ø§Ø±Ùˆ',
            'Ø¯Ø±Ø¯ Ù‡Ø§ÛŒ': 'Ø¯Ø±Ø¯Ù‡Ø§ÛŒ',
            'Ø³Ø± Ø¯Ø±Ø¯': 'Ø³Ø±Ø¯Ø±Ø¯',
            'Ø¨ÛŒÙ…Ø§Ø±Ø³ØªÙˆÙ†': 'Ø¨ÛŒÙ…Ø§Ø±Ø³ØªØ§Ù†'
        }
        
        for wrong, correct in corrections.items():
            text = text.replace(wrong, correct)
            
        return text
```

### Medical Advisor

```python
# chatbot/services/medical_advisor.py

class MedicalAdvisor:
    """Ù…Ø´Ø§ÙˆØ± Ù¾Ø²Ø´Ú©ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯"""
    
    def __init__(self):
        self.ai_service = UnifiedAIService()
        self.knowledge_base = MedicalKnowledgeBase()
        self.response_generator = ResponseGenerator()
        
    async def generate_response(
        self,
        query: Dict,
        user_profile: Dict,
        session_history: List[ChatMessage]
    ) -> Dict:
        """ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø® Ù¾Ø²Ø´Ú©ÛŒ"""
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ prompt
        prompt = await self._prepare_prompt(
            query, user_profile, session_history
        )
        
        # Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± knowledge base
        relevant_info = await self.knowledge_base.search(
            query['entities'],
            query['intent']
        )
        
        # ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø® Ø¨Ø§ AI
        ai_response = await self.ai_service.generate_medical_response(
            prompt,
            context=relevant_info,
            model='gpt-4',
            temperature=0.7
        )
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø§ØµÙ„Ø§Ø­ Ù¾Ø§Ø³Ø®
        validated_response = await self._validate_response(
            ai_response,
            query['intent']
        )
        
        # Ø§ÙØ²ÙˆØ¯Ù† Ù…Ù†Ø§Ø¨Ø¹ Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª
        enriched_response = await self.response_generator.enrich(
            validated_response,
            query,
            user_profile
        )
        
        return enriched_response
        
    async def _prepare_prompt(
        self,
        query: Dict,
        user_profile: Dict,
        session_history: List
    ) -> str:
        """Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ prompt Ø¨Ø±Ø§ÛŒ AI"""
        
        # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø§ÛŒÙ‡ Ú©Ø§Ø±Ø¨Ø±
        user_info = f"""
Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒÙ…Ø§Ø±:
- Ø³Ù†: {user_profile.get('age', 'Ù†Ø§Ù…Ø´Ø®Øµ')} Ø³Ø§Ù„
- Ø¬Ù†Ø³ÛŒØª: {user_profile.get('gender', 'Ù†Ø§Ù…Ø´Ø®Øµ')}
- Ø³Ø§Ø¨Ù‚Ù‡ Ù¾Ø²Ø´Ú©ÛŒ: {', '.join(user_profile.get('medical_history', ['Ù†Ø¯Ø§Ø±Ø¯']))}
- Ø¯Ø§Ø±ÙˆÙ‡Ø§ÛŒ Ù…ØµØ±ÙÛŒ: {', '.join(user_profile.get('medications', ['Ù†Ø¯Ø§Ø±Ø¯']))}
- Ø¢Ù„Ø±Ú˜ÛŒâ€ŒÙ‡Ø§: {', '.join(user_profile.get('allergies', ['Ù†Ø¯Ø§Ø±Ø¯']))}
"""

        # ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ú©Ø§Ù„Ù…Ù‡
        history = "\n".join([
            f"{'Ø¨ÛŒÙ…Ø§Ø±' if msg.sender == 'user' else 'Ù¾Ø²Ø´Ú©'}: {msg.content}"
            for msg in session_history[-5:]  # 5 Ù¾ÛŒØ§Ù… Ø§Ø®ÛŒØ±
        ])
        
        # prompt Ù†Ù‡Ø§ÛŒÛŒ
        prompt = f"""Ø´Ù…Ø§ ÛŒÚ© Ø¯Ø³ØªÛŒØ§Ø± Ù¾Ø²Ø´Ú©ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¯Ø± Ù¾Ù„ØªÙØ±Ù… HELSSA Ù‡Ø³ØªÛŒØ¯.

{user_info}

ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ú©Ø§Ù„Ù…Ù‡:
{history}

Ø³ÙˆØ§Ù„ ÙØ¹Ù„ÛŒ: {query['original']}
Ù‚ØµØ¯ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡: {query['intent']['type']}
Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡: {query['entities']}

Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ù†Ú©Ø§Øª Ø²ÛŒØ± Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯:
1. Ù¾Ø§Ø³Ø® Ø¨Ø§ÛŒØ¯ Ø¯Ù‚ÛŒÙ‚ØŒ Ù‚Ø§Ø¨Ù„ ÙÙ‡Ù… Ùˆ Ø¨Ù‡ Ø²Ø¨Ø§Ù† Ø³Ø§Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
2. Ø§Ø² ØªØ´Ø®ÛŒØµ Ù‚Ø·Ø¹ÛŒ Ùˆ ØªØ¬ÙˆÛŒØ² Ø¯Ø§Ø±Ùˆ Ù¾Ø±Ù‡ÛŒØ² Ú©Ù†ÛŒØ¯
3. Ø¯Ø± Ù…ÙˆØ§Ø±Ø¯ Ø¬Ø¯ÛŒØŒ Ø­ØªÙ…Ø§Ù‹ ØªÙˆØµÛŒÙ‡ Ø¨Ù‡ Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ø­Ø¶ÙˆØ±ÛŒ Ú©Ù†ÛŒØ¯
4. Ù‡Ù…Ø¯Ù„ÛŒ Ùˆ Ø¯Ù„Ø³ÙˆØ²ÛŒ Ø±Ø§ ÙØ±Ø§Ù…ÙˆØ´ Ù†Ú©Ù†ÛŒØ¯
5. Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¹Ù„Ù…ÛŒ Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø§Ø¦Ù‡ Ø¯Ù‡ÛŒØ¯

Ù¾Ø§Ø³Ø® Ø´Ù…Ø§:"""

        return prompt
        
    async def _validate_response(
        self,
        response: str,
        intent: Dict
    ) -> str:
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ùˆ Ø§ØµÙ„Ø§Ø­ Ù¾Ø§Ø³Ø®"""
        
        # Ø­Ø°Ù Ø§Ø¯Ø¹Ø§Ù‡Ø§ÛŒ Ù†Ø§Ù…Ù†Ø§Ø³Ø¨
        forbidden_phrases = [
            'Ù…Ù† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù… ØªØ´Ø®ÛŒØµ Ø¯Ù‡Ù…',
            'Ù‚Ø·Ø¹Ø§Ù‹ Ø¨ÛŒÙ…Ø§Ø±ÛŒ',
            'Ø¯Ø§Ø±Ùˆ Ù…ØµØ±Ù Ú©Ù†ÛŒØ¯',
            'Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ Ù¾Ø²Ø´Ú© Ù†ÛŒØ³Øª'
        ]
        
        for phrase in forbidden_phrases:
            response = response.replace(phrase, '')
            
        # Ø§ÙØ²ÙˆØ¯Ù† disclaimer Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
        if intent['type'] in ['diagnosis_request', 'treatment_request']:
            response += "\n\nâš ï¸ ØªÙˆØ¬Ù‡: Ø§ÛŒÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ù…Ø´Ø§ÙˆØ±Ù‡ Ù¾Ø²Ø´Ú©ÛŒ Ø­Ø¶ÙˆØ±ÛŒ Ù†ÛŒØ³Øª. Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ùˆ Ø¯Ø±Ù…Ø§Ù† Ø¯Ù‚ÛŒÙ‚ Ø­ØªÙ…Ø§Ù‹ Ø¨Ù‡ Ù¾Ø²Ø´Ú© Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ù†ÛŒØ¯."
            
        return response
```

## ğŸ“ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ú©Ø§Ù„Ù…Ø§Øª

### Session Manager

```python
# chatbot/services/session_manager.py

class SessionManager:
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ù„Ø³Ø§Øª Ú†Øª"""
    
    def __init__(self):
        self.redis_client = get_redis_client()
        self.auto_titler = AutoTitler()
        
    async def get_or_create_session(
        self,
        user_id: str,
        session_id: Optional[str] = None
    ) -> ChatSession:
        """Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ù„Ø³Ù‡"""
        
        if session_id:
            try:
                session = await ChatSession.objects.get(
                    id=session_id,
                    user_id=user_id
                )
                
                # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª
                if session.status == 'closed':
                    raise SessionClosedError("Ø¬Ù„Ø³Ù‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª")
                    
                # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø± ØµÙˆØ±Øª idle
                if session.is_idle:
                    session.status = 'active'
                    
                return session
                
            except ChatSession.DoesNotExist:
                pass
                
        # Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ù„Ø³Ù‡ Ø¬Ø¯ÛŒØ¯
        session = await ChatSession.objects.create(
            user_id=user_id,
            status='active'
        )
        
        # Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ú©Ø´
        await self._cache_session(session)
        
        return session
        
    async def close_idle_sessions(self):
        """Ø¨Ø³ØªÙ† Ø¬Ù„Ø³Ø§Øª ØºÛŒØ±ÙØ¹Ø§Ù„"""
        
        idle_threshold = timezone.now() - timedelta(minutes=30)
        
        idle_sessions = await ChatSession.objects.filter(
            status='active',
            last_activity__lt=idle_threshold
        )
        
        for session in idle_sessions:
            await self.close_session(session.id)
            
    async def close_session(
        self,
        session_id: str,
        generate_summary: bool = True
    ) -> ChatSession:
        """Ø¨Ø³ØªÙ† Ø¬Ù„Ø³Ù‡ Ú†Øª"""
        
        session = await ChatSession.objects.get(id=session_id)
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        session.status = 'closed'
        session.closed_at = timezone.now()
        
        # ØªÙˆÙ„ÛŒØ¯ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ¯Ú©Ø§Ø±
        if not session.title:
            session.title = await self.auto_titler.generate_title(session)
            
        await session.save()
        
        # ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡
        if generate_summary and session.message_count > 3:
            await generate_chat_summary.delay(str(session.id))
            
        # Ø­Ø°Ù Ø§Ø² Ú©Ø´
        await self.redis_client.delete(f"session:{session.id}")
        
        return session
        
    async def get_user_sessions(
        self,
        user_id: str,
        status: Optional[str] = None,
        limit: int = 20
    ) -> List[ChatSession]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¬Ù„Ø³Ø§Øª Ú©Ø§Ø±Ø¨Ø±"""
        
        query = ChatSession.objects.filter(user_id=user_id)
        
        if status:
            query = query.filter(status=status)
            
        sessions = await query.order_by('-started_at')[:limit]
        
        # Ø§ÙØ²ÙˆØ¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø®Ù„Ø§ØµÙ‡
        for session in sessions:
            if hasattr(session, 'summary'):
                session.brief_summary = session.summary.brief_summary
            else:
                # Ø®Ù„Ø§ØµÙ‡ Ù…ÙˆÙ‚Øª Ø§Ø² Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒØ§Ù…
                last_message = await ChatMessage.objects.filter(
                    session=session,
                    sender='user'
                ).order_by('-created_at').first()
                
                if last_message:
                    session.brief_summary = last_message.content[:100]
                    
        return sessions
```

### Conversation Flow Manager

```python
# chatbot/services/conversation_flow.py

class ConversationFlowManager:
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ø±ÛŒØ§Ù† Ù…Ú©Ø§Ù„Ù…Ù‡"""
    
    def __init__(self):
        self.state_machine = ConversationStateMachine()
        self.context_tracker = ContextTracker()
        
    async def manage_flow(
        self,
        session: ChatSession,
        current_message: ChatMessage,
        intent: Dict
    ) -> Dict:
        """Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ø±ÛŒØ§Ù† Ù…Ú©Ø§Ù„Ù…Ù‡"""
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ
        current_state = await self._get_conversation_state(session)
        
        # ØªØ¹ÛŒÛŒÙ† ÙˆØ¶Ø¹ÛŒØª Ø¨Ø¹Ø¯ÛŒ
        next_state = await self.state_machine.get_next_state(
            current_state,
            intent['type']
        )
        
        # Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ ÙˆØ¶Ø¹ÛŒØª
        flow_actions = await self._get_flow_actions(
            current_state,
            next_state,
            session
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ context
        await self.context_tracker.update(
            session,
            current_message,
            next_state
        )
        
        return {
            'current_state': current_state,
            'next_state': next_state,
            'actions': flow_actions,
            'requires_info': await self._check_required_info(next_state)
        }
        
    async def _get_flow_actions(
        self,
        current_state: str,
        next_state: str,
        session: ChatSession
    ) -> List[Dict]:
        """ØªØ¹ÛŒÛŒÙ† Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø¬Ø±ÛŒØ§Ù†"""
        
        actions = []
        
        # Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
        if next_state == 'gathering_symptoms':
            actions.append({
                'type': 'ask_questions',
                'questions': await self._get_symptom_questions(session)
            })
            
        # Ø§Ø±Ø§Ø¦Ù‡ ØªÙˆØµÛŒÙ‡
        elif next_state == 'providing_advice':
            actions.append({
                'type': 'give_recommendations',
                'include_references': True
            })
            
        # Ø§Ø±Ø¬Ø§Ø¹ Ø¨Ù‡ Ù¾Ø²Ø´Ú©
        elif next_state == 'referral_needed':
            actions.append({
                'type': 'suggest_doctor',
                'urgency': 'high' if session.urgency_level > 7 else 'normal'
            })
            
        return actions
```

## ğŸ“Š Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„

### Chat Summarizer

```python
# chatbot/services/summarizer.py

class ChatSummarizer:
    """Ø®Ù„Ø§ØµÙ‡â€ŒØ³Ø§Ø² Ù…Ú©Ø§Ù„Ù…Ø§Øª Ú†Øª"""
    
    def __init__(self):
        self.ai_service = UnifiedAIService()
        self.medical_analyzer = MedicalAnalyzer()
        
    async def generate_summary(
        self,
        session_id: str
    ) -> ChatSummary:
        """ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡ Ø¬Ø§Ù…Ø¹ Ù…Ú©Ø§Ù„Ù…Ù‡"""
        
        session = await ChatSession.objects.get(id=session_id)
        messages = await ChatMessage.objects.filter(
            session=session
        ).order_by('created_at')
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø­ØªÙˆØ§
        conversation_text = self._format_conversation(messages)
        
        # ØªÙˆÙ„ÛŒØ¯ Ø§Ù†ÙˆØ§Ø¹ Ø®Ù„Ø§ØµÙ‡
        summaries = await asyncio.gather(
            self._generate_brief_summary(conversation_text),
            self._generate_detailed_summary(conversation_text),
            self._generate_medical_summary(conversation_text, session)
        )
        
        # ØªØ­Ù„ÛŒÙ„ Ù¾Ø²Ø´Ú©ÛŒ
        medical_analysis = await self.medical_analyzer.analyze(
            messages, session
        )
        
        # Ø§ÛŒØ¬Ø§Ø¯ ÛŒØ§ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø®Ù„Ø§ØµÙ‡
        summary, created = await ChatSummary.objects.update_or_create(
            session=session,
            defaults={
                'brief_summary': summaries[0],
                'detailed_summary': summaries[1],
                'medical_summary': summaries[2],
                'key_symptoms': medical_analysis['symptoms'],
                'key_concerns': medical_analysis['concerns'],
                'medical_history_mentioned': medical_analysis['history'],
                'bot_recommendations': medical_analysis['recommendations'],
                'follow_up_needed': medical_analysis['follow_up_needed'],
                'referral_suggested': medical_analysis['referral'],
                'overall_sentiment': medical_analysis['sentiment'],
                'urgency_score': medical_analysis['urgency_score']
            }
        )
        
        return summary
        
    async def _generate_brief_summary(self, text: str) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡ Ú©ÙˆØªØ§Ù‡"""
        
        prompt = f"""Ù…ØªÙ† Ø²ÛŒØ± Ø±Ø§ Ø¯Ø± 2-3 Ø¬Ù…Ù„Ù‡ Ø®Ù„Ø§ØµÙ‡ Ú©Ù†ÛŒØ¯. 
ÙÙ‚Ø· Ù…Ù‡Ù…â€ŒØªØ±ÛŒÙ† Ù†Ú©Ø§Øª Ø±Ø§ Ø°Ú©Ø± Ú©Ù†ÛŒØ¯:

{text[:2000]}

Ø®Ù„Ø§ØµÙ‡:"""

        response = await self.ai_service.generate_text(
            prompt,
            max_tokens=200,
            temperature=0.5
        )
        
        return response['text']
        
    async def _generate_medical_summary(
        self,
        text: str,
        session: ChatSession
    ) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡ Ù¾Ø²Ø´Ú©ÛŒ ØªØ®ØµØµÛŒ"""
        
        prompt = f"""Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© Ù¾Ø²Ø´Ú©ØŒ Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ ØªØ®ØµØµÛŒ Ø§Ø² Ø§ÛŒÙ† Ù…Ú©Ø§Ù„Ù…Ù‡ ØªÙ‡ÛŒÙ‡ Ú©Ù†ÛŒØ¯.
        
Ù…Ú©Ø§Ù„Ù…Ù‡:
{text[:3000]}

Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÚ©Ù…ÛŒÙ„ÛŒ:
- Ø¹Ù„Ø§Ø¦Ù… Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡: {session.identified_symptoms}
- Ø³Ø·Ø­ Ø§ÙˆØ±Ú˜Ø§Ù†Ø³: {session.urgency_level}/10

Ø®Ù„Ø§ØµÙ‡ Ù¾Ø²Ø´Ú©ÛŒ Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„:
1. Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ Ùˆ Ø¹Ù„Ø§Ø¦Ù…
2. Ø³Ø§Ø¨Ù‚Ù‡ Ù…Ø±ØªØ¨Ø·
3. Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
4. ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡
5. Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø¨Ø¹Ø¯ÛŒ

Ø®Ù„Ø§ØµÙ‡ Ù¾Ø²Ø´Ú©ÛŒ:"""

        response = await self.ai_service.generate_text(
            prompt,
            max_tokens=1000,
            temperature=0.3,
            model='gpt-4'
        )
        
        return response['text']
```

### Analytics Service

```python
# chatbot/utils/analytics.py

class ChatAnalyticsService:
    """Ø³Ø±ÙˆÛŒØ³ ØªØ­Ù„ÛŒÙ„ Ú†Øªâ€ŒÙ‡Ø§"""
    
    async def analyze_user_behavior(
        self,
        user_id: str,
        period_days: int = 30
    ) -> Dict:
        """ØªØ­Ù„ÛŒÙ„ Ø±ÙØªØ§Ø± Ú©Ø§Ø±Ø¨Ø±"""
        
        start_date = timezone.now() - timedelta(days=period_days)
        
        # Ø¬Ù„Ø³Ø§Øª Ú©Ø§Ø±Ø¨Ø±
        sessions = await ChatSession.objects.filter(
            user_id=user_id,
            started_at__gte=start_date
        )
        
        # Ø¢Ù…Ø§Ø± Ù¾Ø§ÛŒÙ‡
        total_sessions = await sessions.count()
        total_messages = await ChatMessage.objects.filter(
            session__in=sessions
        ).count()
        
        # ØªÙˆØ²ÛŒØ¹ Ø²Ù…Ø§Ù†ÛŒ
        time_distribution = await self._get_time_distribution(sessions)
        
        # Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ù…Ú©Ø±Ø±
        frequent_topics = await self._get_frequent_topics(sessions)
        
        # Ø±ÙˆÙ†Ø¯ Ø§Ø­Ø³Ø§Ø³Ø§Øª
        sentiment_trend = await self._get_sentiment_trend(sessions)
        
        return {
            'period_days': period_days,
            'total_sessions': total_sessions,
            'total_messages': total_messages,
            'avg_messages_per_session': total_messages / total_sessions if total_sessions > 0 else 0,
            'time_distribution': time_distribution,
            'frequent_topics': frequent_topics,
            'sentiment_trend': sentiment_trend,
            'health_concerns': await self._get_health_concerns(sessions)
        }
```

## ğŸ”— Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø§ Ù¾Ø²Ø´Ú©

### Share Service

```python
# chatbot/services/share_service.py

class ChatShareService:
    """Ø³Ø±ÙˆÛŒØ³ Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú†Øª Ø¨Ø§ Ù¾Ø²Ø´Ú©"""
    
    def __init__(self):
        self.access_manager = AccessManager()
        self.notification_service = NotificationService()
        
    async def share_with_doctor(
        self,
        session_id: str,
        doctor_id: str,
        patient_id: str,
        duration_hours: int = 72
    ) -> Dict:
        """Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¬Ù„Ø³Ù‡ Ú†Øª Ø¨Ø§ Ù¾Ø²Ø´Ú©"""
        
        session = await ChatSession.objects.get(
            id=session_id,
            user_id=patient_id
        )
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø®Ù„Ø§ØµÙ‡
        if not hasattr(session, 'summary'):
            # ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡
            await generate_chat_summary.delay(str(session.id))
            
        # ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† Ø§Ø´ØªØ±Ø§Ú©
        share_token = self._generate_share_token()
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¬Ù„Ø³Ù‡
        session.is_shared = True
        session.share_token = share_token
        await session.save()
        
        # Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø²Ø´Ú© Ø¨Ù‡ Ù„ÛŒØ³Øª
        await session.shared_with.add(doctor_id)
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªØ±Ø³ÛŒ Ù…ÙˆÙ‚Øª
        access_expires = timezone.now() + timedelta(hours=duration_hours)
        
        share_access = await SharedChatAccess.objects.create(
            session=session,
            doctor_id=doctor_id,
            shared_by_id=patient_id,
            expires_at=access_expires,
            access_token=share_token
        )
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù† Ø¨Ù‡ Ù¾Ø²Ø´Ú©
        await self.notification_service.notify_chat_shared(
            doctor_id,
            patient_id,
            session
        )
        
        return {
            'share_token': share_token,
            'share_url': f"{settings.BASE_URL}/shared-chat/{share_token}",
            'expires_at': access_expires.isoformat(),
            'doctor_notified': True
        }
        
    async def get_shared_chat(
        self,
        share_token: str,
        doctor_id: str
    ) -> Dict:
        """Ø¯Ø±ÛŒØ§ÙØª Ú†Øª Ø§Ø´ØªØ±Ø§Ú©ÛŒ"""
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ
        access = await SharedChatAccess.objects.get(
            access_token=share_token,
            doctor_id=doctor_id,
            expires_at__gt=timezone.now()
        )
        
        session = access.session
        
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§
        messages = await ChatMessage.objects.filter(
            session=session
        ).order_by('created_at')
        
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø®Ù„Ø§ØµÙ‡
        summary = None
        if hasattr(session, 'summary'):
            summary = {
                'brief': session.summary.brief_summary,
                'medical': session.summary.medical_summary,
                'symptoms': session.summary.key_symptoms,
                'concerns': session.summary.key_concerns,
                'recommendations': session.summary.bot_recommendations,
                'urgency_score': session.summary.urgency_score
            }
            
        return {
            'session': {
                'id': str(session.id),
                'started_at': session.started_at.isoformat(),
                'duration': session.duration.total_seconds() / 60,
                'message_count': session.message_count,
                'urgency_level': session.urgency_level
            },
            'messages': [
                {
                    'sender': msg.sender,
                    'content': msg.content,
                    'timestamp': msg.created_at.isoformat(),
                    'sentiment': msg.sentiment
                }
                for msg in messages
            ],
            'summary': summary,
            'patient': {
                'name': session.user.get_full_name(),
                'age': calculate_age(session.user.birth_date),
                'gender': session.user.get_gender_display()
            }
        }
```

## ğŸ–¥ï¸ Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú†Øª

### WebSocket Consumer

```python
# chatbot/consumers/chat_consumer.py
from channels.generic.websocket import AsyncWebsocketConsumer
import json

class ChatConsumer(AsyncWebsocketConsumer):
    """WebSocket consumer Ø¨Ø±Ø§ÛŒ Ú†Øª real-time"""
    
    async def connect(self):
        """Ø§ØªØµØ§Ù„ WebSocket"""
        
        self.user = self.scope['user']
        if not self.user.is_authenticated:
            await self.close()
            return
            
        # Ø¯Ø±ÛŒØ§ÙØª ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ù„Ø³Ù‡
        session_id = self.scope['url_route']['kwargs'].get('session_id')
        self.session_manager = SessionManager()
        self.chat_service = MedicalChatService()
        
        self.session = await self.session_manager.get_or_create_session(
            str(self.user.id),
            session_id
        )
        
        # Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡
        self.room_group_name = f'chat_{self.session.id}'
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯
        await self.send_json({
            'type': 'connection_established',
            'session_id': str(self.session.id),
            'message': 'Ø³Ù„Ø§Ù…! Ù…Ù† Ø¯Ø³ØªÛŒØ§Ø± Ù¾Ø²Ø´Ú©ÛŒ Ø´Ù…Ø§ Ù‡Ø³ØªÙ…. Ú†Ø·ÙˆØ± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù… Ú©Ù…Ú©ØªØ§Ù† Ú©Ù†Ù…ØŸ'
        })
        
    async def disconnect(self, close_code):
        """Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„"""
        
        # Ø­Ø°Ù Ø§Ø² Ú¯Ø±ÙˆÙ‡
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¬Ù„Ø³Ù‡
        if hasattr(self, 'session'):
            self.session.status = 'idle'
            await self.session.save()
            
    async def receive_json(self, content):
        """Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù… Ø§Ø² Ú©Ø§Ø±Ø¨Ø±"""
        
        message_type = content.get('type')
        
        if message_type == 'message':
            await self.handle_message(content)
        elif message_type == 'typing':
            await self.handle_typing(content)
        elif message_type == 'voice':
            await self.handle_voice(content)
        elif message_type == 'feedback':
            await self.handle_feedback(content)
            
    async def handle_message(self, content):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ"""
        
        message = content.get('message', '').strip()
        if not message:
            return
            
        # Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ø­Ø§Ù„ ØªØ§ÛŒÙ¾
        await self.send_typing_indicator()
        
        # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…
        try:
            result = await self.chat_service.process_message(
                user_id=str(self.user.id),
                message=message,
                session_id=str(self.session.id)
            )
            
            # Ø§Ø±Ø³Ø§Ù„ Ù¾Ø§Ø³Ø®
            await self.send_json({
                'type': 'bot_message',
                'message': result['response'],
                'message_id': result['message_id'],
                'suggestions': result.get('suggestions', []),
                'references': result.get('references', []),
                'urgency_level': result.get('urgency_level', 0)
            })
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ follow-up
            if result.get('follow_up_needed'):
                await self.send_follow_up_prompt()
                
        except Exception as e:
            await self.send_json({
                'type': 'error',
                'message': 'Ù…ØªØ£Ø³ÙØ§Ù†Ù‡ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù… Ø´Ù…Ø§ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.'
            })
            
    async def handle_voice(self, content):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù… ØµÙˆØªÛŒ"""
        
        audio_data = content.get('audio_data')
        
        # ØªØ¨Ø¯ÛŒÙ„ ØµÙˆØª Ø¨Ù‡ Ù…ØªÙ†
        stt_service = WhisperSTTService()
        transcription = await stt_service.transcribe_audio(
            base64.b64decode(audio_data),
            'voice_message.webm'
        )
        
        # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ØªÙ†
        await self.handle_message({
            'message': transcription['text']
        })
        
    async def send_typing_indicator(self):
        """Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø§Ù†Ú¯Ø± Ø¯Ø± Ø­Ø§Ù„ ØªØ§ÛŒÙ¾"""
        
        await self.send_json({
            'type': 'typing',
            'is_typing': True
        })
        
        # ØªÙˆÙ‚Ù Ø¨Ø¹Ø¯ Ø§Ø² Ù¾Ø§Ø³Ø®
        asyncio.create_task(self._stop_typing_after_delay())
        
    async def _stop_typing_after_delay(self):
        """ØªÙˆÙ‚Ù Ù†Ø´Ø§Ù†Ú¯Ø± ØªØ§ÛŒÙ¾"""
        
        await asyncio.sleep(2)
        await self.send_json({
            'type': 'typing',
            'is_typing': False
        })
```

### Chat API Views

```python
# chatbot/api/views.py

class ChatViewSet(viewsets.ModelViewSet):
    """API endpoints Ø¨Ø±Ø§ÛŒ Ú†Øª"""
    
    serializer_class = ChatSessionSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return ChatSession.objects.filter(
            user=self.request.user
        ).order_by('-started_at')
        
    @action(detail=True, methods=['get'])
    async def messages(self, request, pk=None):
        """Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ø¬Ù„Ø³Ù‡"""
        
        session = self.get_object()
        messages = await ChatMessage.objects.filter(
            session=session
        ).order_by('created_at')
        
        serializer = ChatMessageSerializer(messages, many=True)
        return Response(serializer.data)
        
    @action(detail=True, methods=['post'])
    async def share(self, request, pk=None):
        """Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú†Øª Ø¨Ø§ Ù¾Ø²Ø´Ú©"""
        
        session = self.get_object()
        doctor_id = request.data.get('doctor_id')
        
        if not doctor_id:
            return Response(
                {'error': 'Ø´Ù†Ø§Ø³Ù‡ Ù¾Ø²Ø´Ú© Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'},
                status=status.HTTP_400_BAD_REQUEST
            )
            
        share_service = ChatShareService()
        result = await share_service.share_with_doctor(
            session_id=str(session.id),
            doctor_id=doctor_id,
            patient_id=str(request.user.id)
        )
        
        return Response(result)
        
    @action(detail=True, methods=['get'])
    async def summary(self, request, pk=None):
        """Ø¯Ø±ÛŒØ§ÙØª Ø®Ù„Ø§ØµÙ‡ Ú†Øª"""
        
        session = self.get_object()
        
        try:
            summary = await ChatSummary.objects.get(session=session)
            serializer = ChatSummarySerializer(summary)
            return Response(serializer.data)
        except ChatSummary.DoesNotExist:
            # ØªÙˆÙ„ÛŒØ¯ Ø®Ù„Ø§ØµÙ‡
            summarizer = ChatSummarizer()
            summary = await summarizer.generate_summary(str(session.id))
            serializer = ChatSummarySerializer(summary)
            return Response(serializer.data)
            
    @action(detail=False, methods=['get'])
    async def statistics(self, request):
        """Ø¢Ù…Ø§Ø± Ú†Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
        
        analytics = ChatAnalyticsService()
        stats = await analytics.analyze_user_behavior(
            user_id=str(request.user.id),
            period_days=int(request.query_params.get('days', 30))
        )
        
        return Response(stats)
```

---

[ELEMENT: div align="center"]

[â†’ Ù‚Ø¨Ù„ÛŒ: Ø¯Ø³ØªØ±Ø³ÛŒ Ù¾Ø²Ø´Ú© Ø¨Ù‡ Ø¨ÛŒÙ…Ø§Ø±](09-doctor-access.md) | [Ø¨Ø¹Ø¯ÛŒ: Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª Ùˆ STT â†](11-audio-processing.md)

</div>
