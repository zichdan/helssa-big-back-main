# ğŸ’° Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ Ùˆ Ø§Ø´ØªØ±Ø§Ú© HELSSA

## ğŸ“‹ ÙÙ‡Ø±Ø³Øª Ù…Ø·Ø§Ù„Ø¨

- [Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ](## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ)
- [Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ](## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ)
- [Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„](## ğŸ’³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„)
- [Ø³ÛŒØ³ØªÙ… Ø§Ø´ØªØ±Ø§Ú©](## ğŸ’³ Ø³ÛŒØ³ØªÙ… Ø§Ø´ØªØ±Ø§Ú©)
- [Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª](## ğŸ’³ Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª)
- [Ù…Ø¯ÛŒØ±ÛŒØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§](## ğŸ’³ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§)
- [Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ](## ğŸ’³ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ)
- [Ø§Ù…Ù†ÛŒØª Ù…Ø§Ù„ÛŒ](## ğŸ”’ Ø§Ù…Ù†ÛŒØª Ù…Ø§Ù„ÛŒ)

---

## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ

Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ HELSSA ÛŒÚ© Ù¾Ù„ØªÙØ±Ù… Ø¬Ø§Ù…Ø¹ Ùˆ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ…Ø§Ù… Ø¬Ù†Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ù¾Ù„ØªÙØ±Ù… Ø§Ø³Øª Ú©Ù‡ Ø´Ø§Ù…Ù„ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ØŒ Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ØŒ Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§ Ùˆ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯.

### ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

- ğŸ’³ **Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÛŒØ¬ÛŒØªØ§Ù„** Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ø§Ø±Ø¨Ø±
- ğŸ“Š **Ù¾Ù„Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ù…ØªÙ†ÙˆØ¹** Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø³ÙØ§Ø±Ø´ÛŒâ€ŒØ³Ø§Ø²ÛŒ
- ğŸ¦ **Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ØªØ¹Ø¯Ø¯** (Ø§ÛŒØ±Ø§Ù†ÛŒ Ùˆ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ)
- ğŸ’¸ **Ø³ÛŒØ³ØªÙ… Ú©Ù…ÛŒØ³ÛŒÙˆÙ† Ù‡ÙˆØ´Ù…Ù†Ø¯** Ø¨Ø±Ø§ÛŒ Ù¾Ø²Ø´Ú©Ø§Ù†
- ğŸ“ˆ **Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø¬Ø§Ù…Ø¹** Ùˆ Real-time
- ğŸ” **Ø§Ù…Ù†ÛŒØª Ø¨Ø§Ù„Ø§** Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯Ù‡Ø§ÛŒ PCI DSS
- ğŸ”„ **ØªØ³ÙˆÛŒÙ‡ Ø­Ø³Ø§Ø¨ Ø®ÙˆØ¯Ú©Ø§Ø±** Ø¨Ø§ Ù¾Ø²Ø´Ú©Ø§Ù†

## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ

```mermaid
graph TB
    subgraph "Payment Gateways"
        BP[BitPay.ir]
        ZP[ZarinPal]
        IP[IDPay]
        ST[Stripe]
        PP[PayPal]
    end
    
    subgraph "Billing System Core"
        PC[Payment Controller]
        WM[Wallet Manager]
        SM[Subscription Manager]
        TM[Transaction Manager]
        CM[Commission Manager]
    end
    
    subgraph "Financial Services"
        INV[Invoice Service]
        REF[Refund Service]
        SET[Settlement Service]
        REP[Report Service]
    end
    
    subgraph "Data Layer"
        WDB[(Wallet DB)]
        TDB[(Transaction DB)]
        SDB[(Subscription DB)]
        CACHE[(Redis Cache)]
    end
    
    subgraph "Security Layer"
        ENC[Encryption Service]
        AUD[Audit Logger]
        FRD[Fraud Detection]
    end
    
    BP --> PC
    ZP --> PC
    IP --> PC
    ST --> PC
    PP --> PC
    
    PC --> TM
    PC --> WM
    
    WM --> WDB
    TM --> TDB
    SM --> SDB
    
    All --> CACHE
    All --> ENC
    All --> AUD
```

### Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Ù…Ø§Ù„ÛŒ

```python
unified_billing/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ wallet.py               # Ù…Ø¯Ù„ Ú©ÛŒÙ Ù¾ÙˆÙ„
â”‚   â”œâ”€â”€ transaction.py          # Ù…Ø¯Ù„ ØªØ±Ø§Ú©Ù†Ø´
â”‚   â”œâ”€â”€ subscription.py         # Ù…Ø¯Ù„ Ø§Ø´ØªØ±Ø§Ú©
â”‚   â”œâ”€â”€ plan.py                 # Ù…Ø¯Ù„ Ù¾Ù„Ù†â€ŒÙ‡Ø§
â”‚   â”œâ”€â”€ invoice.py              # Ù…Ø¯Ù„ ÙØ§Ú©ØªÙˆØ±
â”‚   â””â”€â”€ commission.py           # Ù…Ø¯Ù„ Ú©Ù…ÛŒØ³ÛŒÙˆÙ†
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ wallet_service.py       # Ø³Ø±ÙˆÛŒØ³ Ú©ÛŒÙ Ù¾ÙˆÙ„
â”‚   â”œâ”€â”€ payment_service.py      # Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø®Øª
â”‚   â”œâ”€â”€ subscription_service.py # Ø³Ø±ÙˆÛŒØ³ Ø§Ø´ØªØ±Ø§Ú©
â”‚   â”œâ”€â”€ commission_service.py   # Ø³Ø±ÙˆÛŒØ³ Ú©Ù…ÛŒØ³ÛŒÙˆÙ†
â”‚   â””â”€â”€ settlement_service.py   # Ø³Ø±ÙˆÛŒØ³ ØªØ³ÙˆÛŒÙ‡
â”œâ”€â”€ gateways/
â”‚   â”œâ”€â”€ base_gateway.py         # Ú©Ù„Ø§Ø³ Ù¾Ø§ÛŒÙ‡
â”‚   â”œâ”€â”€ bitpay_gateway.py       # BitPay.ir
â”‚   â”œâ”€â”€ zarinpal_gateway.py     # ZarinPal
â”‚   â”œâ”€â”€ idpay_gateway.py        # IDPay
â”‚   â””â”€â”€ stripe_gateway.py       # Stripe
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ currency_converter.py   # ØªØ¨Ø¯ÛŒÙ„ Ø§Ø±Ø²
â”‚   â”œâ”€â”€ invoice_generator.py    # ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ±
â”‚   â””â”€â”€ financial_calculator.py # Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ù…Ø§Ù„ÛŒ
â”œâ”€â”€ tasks.py                     # Celery tasks
â”œâ”€â”€ webhooks/                    # Webhook handlers
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ serializers.py
â”‚   â””â”€â”€ views.py
â””â”€â”€ migrations/
```

## ğŸ’³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„

### Wallet Model

```python
# unified_billing/models/wallet.py
from decimal import Decimal
from django.db import models, transaction
import uuid

class Wallet(models.Model):
    """Ù…Ø¯Ù„ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÛŒØ¬ÛŒØªØ§Ù„"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.OneToOneField(
        'unified_auth.UnifiedUser',
        on_delete=models.PROTECT,
        related_name='wallet'
    )
    
    # Ù…ÙˆØ¬ÙˆØ¯ÛŒâ€ŒÙ‡Ø§
    balance = models.DecimalField(
        max_digits=12,
        decimal_places=0,
        default=0,
        help_text="Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ù‡ Ø±ÛŒØ§Ù„"
    )
    blocked_balance = models.DecimalField(
        max_digits=12,
        decimal_places=0,
        default=0,
        help_text="Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ù„ÙˆÚ©Ù‡ Ø´Ø¯Ù‡"
    )
    
    # Ø§Ø¹ØªØ¨Ø§Ø± Ù‡Ø¯ÛŒÙ‡
    gift_credit = models.DecimalField(
        max_digits=10,
        decimal_places=0,
        default=0,
        help_text="Ø§Ø¹ØªØ¨Ø§Ø± Ù‡Ø¯ÛŒÙ‡"
    )
    gift_credit_expires_at = models.DateTimeField(null=True, blank=True)
    
    # ÙˆØ¶Ø¹ÛŒØª
    is_active = models.BooleanField(default=True)
    is_verified = models.BooleanField(default=False)
    
    # Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§
    daily_withdrawal_limit = models.DecimalField(
        max_digits=10,
        decimal_places=0,
        default=50000000  # 50 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„
    )
    monthly_withdrawal_limit = models.DecimalField(
        max_digits=10,
        decimal_places=0,
        default=500000000  # 500 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„
    )
    
    # Ø²Ù…Ø§Ù†â€ŒÙ‡Ø§
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_transaction_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'wallets'
        indexes = [
            models.Index(fields=['user', 'is_active']),
        ]
        
    @property
    def available_balance(self) -> Decimal:
        """Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡"""
        return self.balance - self.blocked_balance
        
    def has_sufficient_balance(self, amount: Decimal) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ú©ÙØ§ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ"""
        return self.available_balance >= amount
```

### Wallet Service

```python
# unified_billing/services/wallet_service.py
from decimal import Decimal
from typing import Dict, Optional
from django.db import transaction as db_transaction

class WalletService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„"""
    
    def __init__(self):
        self.transaction_service = TransactionService()
        self.notification_service = NotificationService()
        
    @db_transaction.atomic
    async def deposit(
        self,
        wallet_id: str,
        amount: Decimal,
        source: str,
        reference: str,
        metadata: Optional[Dict] = None
    ) -> Transaction:
        """ÙˆØ§Ø±ÛŒØ² Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„"""
        
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ø§ Ù‚ÙÙ„
        wallet = await Wallet.objects.select_for_update().get(
            id=wallet_id,
            is_active=True
        )
        
        # Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´
        transaction = await self.transaction_service.create_transaction(
            wallet=wallet,
            amount=amount,
            type=TransactionType.DEPOSIT,
            source=source,
            reference=reference,
            metadata=metadata
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
        wallet.balance += amount
        wallet.last_transaction_at = timezone.now()
        await wallet.save()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        await self.notification_service.send_deposit_notification(
            wallet.user,
            amount,
            wallet.balance
        )
        
        return transaction
        
    @db_transaction.atomic
    async def withdraw(
        self,
        wallet_id: str,
        amount: Decimal,
        destination: str,
        metadata: Optional[Dict] = None
    ) -> Transaction:
        """Ø¨Ø±Ø¯Ø§Ø´Øª Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„"""
        
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ø§ Ù‚ÙÙ„
        wallet = await Wallet.objects.select_for_update().get(
            id=wallet_id,
            is_active=True
        )
        
        # Ø¨Ø±Ø±Ø³ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ
        await self._validate_withdrawal(wallet, amount)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
        if not wallet.has_sufficient_balance(amount):
            raise InsufficientBalanceError(
                f"Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª. Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ: {wallet.available_balance}"
            )
            
        # Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´
        transaction = await self.transaction_service.create_transaction(
            wallet=wallet,
            amount=-amount,
            type=TransactionType.WITHDRAWAL,
            destination=destination,
            metadata=metadata
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
        wallet.balance -= amount
        wallet.last_transaction_at = timezone.now()
        await wallet.save()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        await self.notification_service.send_withdrawal_notification(
            wallet.user,
            amount,
            wallet.balance
        )
        
        return transaction
        
    @db_transaction.atomic
    async def transfer(
        self,
        from_wallet_id: str,
        to_wallet_id: str,
        amount: Decimal,
        description: str = "",
        commission_rate: Decimal = Decimal('0')
    ) -> Dict[str, Transaction]:
        """Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨ÛŒÙ† Ú©ÛŒÙ Ù¾ÙˆÙ„â€ŒÙ‡Ø§"""
        
        # Ù‚ÙÙ„ Ù‡Ø± Ø¯Ùˆ Ú©ÛŒÙ Ù¾ÙˆÙ„
        wallets = await Wallet.objects.select_for_update().filter(
            id__in=[from_wallet_id, to_wallet_id],
            is_active=True
        ).order_by('id')  # Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² deadlock
        
        if len(wallets) != 2:
            raise WalletNotFoundError("ÛŒÚ©ÛŒ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„â€ŒÙ‡Ø§ ÛŒØ§ÙØª Ù†Ø´Ø¯")
            
        from_wallet = next(w for w in wallets if str(w.id) == from_wallet_id)
        to_wallet = next(w for w in wallets if str(w.id) == to_wallet_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
        total_amount = amount + (amount * commission_rate)
        if not from_wallet.has_sufficient_balance(total_amount):
            raise InsufficientBalanceError("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª")
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù…ÛŒØ³ÛŒÙˆÙ†
        commission = amount * commission_rate
        net_amount = amount - commission
        
        # ØªØ±Ø§Ú©Ù†Ø´ Ø¨Ø±Ø¯Ø§Ø´Øª
        from_transaction = await self.transaction_service.create_transaction(
            wallet=from_wallet,
            amount=-amount,
            type=TransactionType.TRANSFER_OUT,
            related_wallet=to_wallet,
            description=description
        )
        
        # ØªØ±Ø§Ú©Ù†Ø´ ÙˆØ§Ø±ÛŒØ²
        to_transaction = await self.transaction_service.create_transaction(
            wallet=to_wallet,
            amount=net_amount,
            type=TransactionType.TRANSFER_IN,
            related_wallet=from_wallet,
            description=description,
            related_transaction=from_transaction
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒâ€ŒÙ‡Ø§
        from_wallet.balance -= amount
        to_wallet.balance += net_amount
        
        await from_wallet.save()
        await to_wallet.save()
        
        # Ø«Ø¨Øª Ú©Ù…ÛŒØ³ÛŒÙˆÙ† Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯
        commission_transaction = None
        if commission > 0:
            commission_transaction = await self._record_commission(
                amount=commission,
                source_transaction=from_transaction
            )
            
        return {
            'from': from_transaction,
            'to': to_transaction,
            'commission': commission_transaction
        }
        
    async def _validate_withdrawal(
        self,
        wallet: Wallet,
        amount: Decimal
    ):
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¨Ø±Ø¯Ø§Ø´Øª"""
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø±ÙˆØ²Ø§Ù†Ù‡
        daily_total = await self._get_daily_withdrawal_total(wallet)
        if daily_total + amount > wallet.daily_withdrawal_limit:
            raise WithdrawalLimitExceeded(
                f"Ø§Ø² Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø¨Ø±Ø¯Ø§Ø´Øª Ø±ÙˆØ²Ø§Ù†Ù‡ ({wallet.daily_withdrawal_limit} Ø±ÛŒØ§Ù„) ØªØ¬Ø§ÙˆØ² Ù…ÛŒâ€ŒÚ©Ù†Ø¯"
            )
            
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø§Ù‡Ø§Ù†Ù‡
        monthly_total = await self._get_monthly_withdrawal_total(wallet)
        if monthly_total + amount > wallet.monthly_withdrawal_limit:
            raise WithdrawalLimitExceeded(
                f"Ø§Ø² Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø¨Ø±Ø¯Ø§Ø´Øª Ù…Ø§Ù‡Ø§Ù†Ù‡ ({wallet.monthly_withdrawal_limit} Ø±ÛŒØ§Ù„) ØªØ¬Ø§ÙˆØ² Ù…ÛŒâ€ŒÚ©Ù†Ø¯"
            )
            
        # Ø¨Ø±Ø±Ø³ÛŒ ØªØ§ÛŒÛŒØ¯ Ù‡ÙˆÛŒØª Ø¨Ø±Ø§ÛŒ Ù…Ø¨Ø§Ù„Øº Ø¨Ø§Ù„Ø§
        if amount > 10000000 and not wallet.is_verified:  # 10 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„
            raise VerificationRequiredError(
                "Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø´Øª Ù…Ø¨Ø§Ù„Øº Ø¨Ø§Ù„Ø§ÛŒ 10 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„ØŒ ØªØ§ÛŒÛŒØ¯ Ù‡ÙˆÛŒØª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
            )
```

## ğŸ“Š Ø³ÛŒØ³ØªÙ… Ø§Ø´ØªØ±Ø§Ú©

### Subscription Plans

```python
# unified_billing/models/plan.py

class SubscriptionPlan(models.Model):
    """Ù…Ø¯Ù„ Ù¾Ù„Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØ±Ø§Ú©"""
    
    PLAN_TYPES = [
        ('patient_free', 'Ø¨ÛŒÙ…Ø§Ø± - Ø±Ø§ÛŒÚ¯Ø§Ù†'),
        ('patient_basic', 'Ø¨ÛŒÙ…Ø§Ø± - Ù¾Ø§ÛŒÙ‡'),
        ('patient_premium', 'Ø¨ÛŒÙ…Ø§Ø± - Ø·Ù„Ø§ÛŒÛŒ'),
        ('doctor_basic', 'Ù¾Ø²Ø´Ú© - Ù¾Ø§ÛŒÙ‡'),
        ('doctor_professional', 'Ù¾Ø²Ø´Ú© - Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ'),
        ('doctor_enterprise', 'Ù¾Ø²Ø´Ú© - Ø³Ø§Ø²Ù…Ø§Ù†ÛŒ'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    name = models.CharField(max_length=100)
    type = models.CharField(max_length=30, choices=PLAN_TYPES, unique=True)
    
    # Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ
    monthly_price = models.DecimalField(max_digits=10, decimal_places=0)
    yearly_price = models.DecimalField(max_digits=10, decimal_places=0)
    
    # Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§
    limits = models.JSONField(default=dict)
    """
    {
        "chat_messages_daily": 20,
        "chat_messages_monthly": 500,
        "stt_minutes_monthly": 120,
        "image_analysis_monthly": 10,
        "video_visits_monthly": 5,
        "soap_reports_monthly": 50,
        "storage_gb": 5
    }
    """
    
    # ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§
    features = models.JSONField(default=list)
    """
    [
        "chat_with_ai",
        "voice_to_text",
        "image_analysis",
        "video_visit",
        "soap_generation",
        "patient_management",
        "appointment_scheduling",
        "sms_reminders",
        "priority_support"
    ]
    """
    
    # Ú©Ù…ÛŒØ³ÛŒÙˆÙ† (Ø¨Ø±Ø§ÛŒ Ù¾Ø²Ø´Ú©Ø§Ù†)
    commission_rate = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=0,
        help_text="Ø¯Ø±ØµØ¯ Ú©Ù…ÛŒØ³ÛŒÙˆÙ† Ù¾Ù„ØªÙØ±Ù…"
    )
    
    # ÙˆØ¶Ø¹ÛŒØª
    is_active = models.BooleanField(default=True)
    is_recommended = models.BooleanField(default=False)
    
    # Ù…ØªØ§
    display_order = models.IntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'subscription_plans'
        ordering = ['display_order', 'monthly_price']
```

### Subscription Model

```python
# unified_billing/models/subscription.py

class Subscription(models.Model):
    """Ù…Ø¯Ù„ Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"""
    
    STATUS_CHOICES = [
        ('trial', 'Ø¯ÙˆØ±Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ'),
        ('active', 'ÙØ¹Ø§Ù„'),
        ('past_due', 'Ù…Ø¹ÙˆÙ‚'),
        ('cancelled', 'Ù„ØºÙˆ Ø´Ø¯Ù‡'),
        ('expired', 'Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.ForeignKey(
        'unified_auth.UnifiedUser',
        on_delete=models.PROTECT,
        related_name='subscriptions'
    )
    plan = models.ForeignKey(
        SubscriptionPlan,
        on_delete=models.PROTECT
    )
    
    # ÙˆØ¶Ø¹ÛŒØª
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='trial'
    )
    
    # Ø¯ÙˆØ±Ù‡ Ø§Ø´ØªØ±Ø§Ú©
    billing_cycle = models.CharField(
        max_length=10,
        choices=[('monthly', 'Ù…Ø§Ù‡Ø§Ù†Ù‡'), ('yearly', 'Ø³Ø§Ù„Ø§Ù†Ù‡')],
        default='monthly'
    )
    
    # ØªØ§Ø±ÛŒØ®â€ŒÙ‡Ø§
    trial_end_date = models.DateTimeField(null=True, blank=True)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    cancelled_at = models.DateTimeField(null=True, blank=True)
    
    # Ù¾Ø±Ø¯Ø§Ø®Øª
    auto_renew = models.BooleanField(default=True)
    next_billing_date = models.DateTimeField()
    payment_method = models.CharField(
        max_length=20,
        choices=[
            ('wallet', 'Ú©ÛŒÙ Ù¾ÙˆÙ„'),
            ('card', 'Ú©Ø§Ø±Øª Ø¨Ø§Ù†Ú©ÛŒ'),
            ('gateway', 'Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª')
        ],
        default='wallet'
    )
    
    # Ø§Ø³ØªÙØ§Ø¯Ù‡
    usage_data = models.JSONField(default=dict)
    """
    {
        "chat_messages": 150,
        "stt_minutes": 45.5,
        "image_analysis": 3,
        "video_visits": 2
    }
    """
    
    # Ù…ØªØ§
    metadata = models.JSONField(default=dict)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'subscriptions'
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['next_billing_date']),
        ]
```

### Subscription Service

```python
# unified_billing/services/subscription_service.py

class SubscriptionService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.wallet_service = WalletService()
        self.payment_service = PaymentService()
        self.usage_tracker = UsageTracker()
        
    async def create_subscription(
        self,
        user_id: str,
        plan_id: str,
        billing_cycle: str = 'monthly',
        payment_method: str = 'wallet',
        start_trial: bool = True
    ) -> Subscription:
        """Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú© Ø¬Ø¯ÛŒØ¯"""
        
        user = await UnifiedUser.objects.get(id=user_id)
        plan = await SubscriptionPlan.objects.get(id=plan_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„
        active_subscription = await self._get_active_subscription(user)
        if active_subscription:
            raise SubscriptionExistsError(
                "Ø´Ù…Ø§ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„ Ø¯Ø§Ø±ÛŒØ¯"
            )
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ§Ø±ÛŒØ®â€ŒÙ‡Ø§
        now = timezone.now()
        trial_days = 7 if start_trial and plan.type.startswith('patient') else 0
        
        if trial_days > 0:
            start_date = now
            trial_end_date = now + timedelta(days=trial_days)
            end_date = trial_end_date
            next_billing_date = trial_end_date
            status = 'trial'
        else:
            start_date = now
            trial_end_date = None
            
            if billing_cycle == 'monthly':
                end_date = now + timedelta(days=30)
            else:  # yearly
                end_date = now + timedelta(days=365)
                
            next_billing_date = end_date
            status = 'active'
            
            # Ù¾Ø±Ø¯Ø§Ø®Øª Ø§ÙˆÙ„ÛŒÙ‡
            await self._process_initial_payment(
                user, plan, billing_cycle, payment_method
            )
            
        # Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú©
        subscription = await Subscription.objects.create(
            user=user,
            plan=plan,
            status=status,
            billing_cycle=billing_cycle,
            trial_end_date=trial_end_date,
            start_date=start_date,
            end_date=end_date,
            next_billing_date=next_billing_date,
            payment_method=payment_method
        )
        
        # Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„ Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯
        await self._send_welcome_email(user, plan, subscription)
        
        return subscription
        
    async def upgrade_subscription(
        self,
        subscription_id: str,
        new_plan_id: str
    ) -> Subscription:
        """Ø§Ø±ØªÙ‚Ø§Ø¡ Ø§Ø´ØªØ±Ø§Ú©"""
        
        subscription = await Subscription.objects.select_for_update().get(
            id=subscription_id,
            status__in=['active', 'trial']
        )
        
        new_plan = await SubscriptionPlan.objects.get(id=new_plan_id)
        old_plan = subscription.plan
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø§Ø¨Ù‡â€ŒØ§Ù„ØªÙØ§ÙˆØª
        if subscription.billing_cycle == 'monthly':
            old_price = old_plan.monthly_price
            new_price = new_plan.monthly_price
        else:
            old_price = old_plan.yearly_price
            new_price = new_plan.yearly_price
            
        if new_price <= old_price:
            raise InvalidUpgradeError(
                "Ù¾Ù„Ù† Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø¨Ø§ÛŒØ¯ Ø§Ø² Ù¾Ù„Ù† ÙØ¹Ù„ÛŒ Ø¨Ø§Ù„Ø§ØªØ± Ø¨Ø§Ø´Ø¯"
            )
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø¹ØªØ¨Ø§Ø± Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡
        days_remaining = (subscription.end_date - timezone.now()).days
        total_days = 30 if subscription.billing_cycle == 'monthly' else 365
        
        remaining_credit = (old_price * days_remaining) / total_days
        amount_due = new_price - remaining_credit
        
        # Ù¾Ø±Ø¯Ø§Ø®Øª Ù…Ø§Ø¨Ù‡â€ŒØ§Ù„ØªÙØ§ÙˆØª
        if amount_due > 0:
            await self._process_payment(
                subscription.user,
                amount_due,
                f"Ø§Ø±ØªÙ‚Ø§Ø¡ Ø§Ø´ØªØ±Ø§Ú© Ø§Ø² {old_plan.name} Ø¨Ù‡ {new_plan.name}"
            )
            
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú©
        subscription.plan = new_plan
        subscription.updated_at = timezone.now()
        await subscription.save()
        
        # Ø±ÛŒØ³Øª Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡
        await self.usage_tracker.reset_limits(subscription.user.id)
        
        return subscription
        
    async def cancel_subscription(
        self,
        subscription_id: str,
        reason: Optional[str] = None,
        immediate: bool = False
    ) -> Subscription:
        """Ù„ØºÙˆ Ø§Ø´ØªØ±Ø§Ú©"""
        
        subscription = await Subscription.objects.get(
            id=subscription_id,
            status__in=['active', 'trial']
        )
        
        if immediate:
            # Ù„ØºÙˆ ÙÙˆØ±ÛŒ
            subscription.status = 'cancelled'
            subscription.end_date = timezone.now()
        else:
            # Ù„ØºÙˆ Ø¯Ø± Ù¾Ø§ÛŒØ§Ù† Ø¯ÙˆØ±Ù‡
            subscription.auto_renew = False
            subscription.status = 'active'  # ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø¯ÙˆØ±Ù‡ ÙØ¹Ø§Ù„ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯
            
        subscription.cancelled_at = timezone.now()
        await subscription.save()
        
        # Ø«Ø¨Øª Ø¯Ù„ÛŒÙ„ Ù„ØºÙˆ
        if reason:
            await CancellationReason.objects.create(
                subscription=subscription,
                reason=reason
            )
            
        # Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„ ØªØ§ÛŒÛŒØ¯ Ù„ØºÙˆ
        await self._send_cancellation_email(
            subscription.user,
            subscription,
            immediate
        )
        
        return subscription
        
    async def check_usage_limit(
        self,
        user_id: str,
        resource: str,
        amount: int = 1
    ) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø§Ø³ØªÙØ§Ø¯Ù‡"""
        
        subscription = await self._get_active_subscription_by_user_id(user_id)
        if not subscription:
            return False
            
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§
        limits = subscription.plan.limits
        limit_key = f"{resource}_monthly"
        
        if limit_key not in limits:
            return True  # Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª
            
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ ÙØ¹Ù„ÛŒ
        current_usage = subscription.usage_data.get(resource, 0)
        limit = limits[limit_key]
        
        if limit == -1:  # Ù†Ø§Ù…Ø­Ø¯ÙˆØ¯
            return True
            
        return current_usage + amount <= limit
        
    @shared_task
    async def process_recurring_payments(self):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ"""
        
        # Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ ØªÙ…Ø¯ÛŒØ¯ Ø´ÙˆÙ†Ø¯
        due_subscriptions = await Subscription.objects.filter(
            status='active',
            auto_renew=True,
            next_billing_date__lte=timezone.now()
        ).select_related('user', 'plan')
        
        for subscription in due_subscriptions:
            try:
                await self._renew_subscription(subscription)
            except Exception as e:
                await self._handle_payment_failure(subscription, str(e))
```

## ğŸ¦ Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª

### Base Gateway Interface

```python
# unified_billing/gateways/base_gateway.py
from abc import ABC, abstractmethod
from typing import Dict, Optional

class BasePaymentGateway(ABC):
    """Ø§ÛŒÙ†ØªØ±ÙÛŒØ³ Ù¾Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.name = self.__class__.__name__
        
    @abstractmethod
    async def create_payment(
        self,
        amount: int,
        order_id: str,
        callback_url: str,
        description: str = "",
        mobile: Optional[str] = None,
        email: Optional[str] = None
    ) -> Dict:
        """Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¬Ø¯ÛŒØ¯"""
        pass
        
    @abstractmethod
    async def verify_payment(
        self,
        reference: str,
        amount: Optional[int] = None
    ) -> Dict:
        """ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª"""
        pass
        
    @abstractmethod
    async def refund_payment(
        self,
        reference: str,
        amount: Optional[int] = None
    ) -> Dict:
        """Ø¨Ø§Ø²Ú¯Ø´Øª ÙˆØ¬Ù‡"""
        pass
        
    def validate_amount(self, amount: int):
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…Ø¨Ù„Øº"""
        if amount < 1000:
            raise ValueError("Ø­Ø¯Ø§Ù‚Ù„ Ù…Ø¨Ù„Øº Ù¾Ø±Ø¯Ø§Ø®Øª 1000 Ø±ÛŒØ§Ù„ Ø§Ø³Øª")
        if amount > 500000000:
            raise ValueError("Ø­Ø¯Ø§Ú©Ø«Ø± Ù…Ø¨Ù„Øº Ù¾Ø±Ø¯Ø§Ø®Øª 500 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„ Ø§Ø³Øª")
```

### BitPay.ir Gateway

```python
# unified_billing/gateways/bitpay_gateway.py
import aiohttp
import hashlib
from typing import Dict, Optional

class BitPayGateway(BasePaymentGateway):
    """Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª BitPay.ir"""
    
    def __init__(self, config: Dict):
        super().__init__(config)
        self.api_key = config['api_key']
        self.base_url = config.get('base_url', 'https://bitpay.ir/payment')
        self.callback_url = config['callback_url']
        
    async def create_payment(
        self,
        amount: int,
        order_id: str,
        callback_url: str,
        description: str = "",
        mobile: Optional[str] = None,
        email: Optional[str] = None
    ) -> Dict:
        """Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¯Ø± BitPay"""
        
        self.validate_amount(amount)
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        data = {
            'api': self.api_key,
            'amount': amount,
            'factorId': order_id,
            'redirect': callback_url or self.callback_url,
            'name': mobile or '',
            'email': email or '',
            'description': description or f'Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ {order_id}'
        }
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/gateway-send",
                data=data
            ) as response:
                result = await response.json()
                
        # Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§Ø³Ø®
        if result.get('status') == -1:
            return {
                'success': True,
                'payment_url': f"{self.base_url}/gateway/{result['id_get']}",
                'reference': result['id_get'],
                'gateway': 'bitpay'
            }
        else:
            error_messages = {
                -2: 'transId ÛŒØ§ÙØª Ù†Ø´Ø¯',
                -3: 'api_key ÛŒØ§ÙØª Ù†Ø´Ø¯',
                -4: 'amount Ù†Ø§Ù…Ø¹ØªØ¨Ø±',
                -5: 'ÙˆØ§Ø­Ø¯ Ù¾ÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø±',
                -6: 'transId ØªÚ©Ø±Ø§Ø±ÛŒ',
                -7: 'api_key Ù†Ø§Ù…Ø¹ØªØ¨Ø±'
            }
            
            raise PaymentGatewayError(
                error_messages.get(result['status'], 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡')
            )
            
    async def verify_payment(
        self,
        reference: str,
        amount: Optional[int] = None
    ) -> Dict:
        """ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª BitPay"""
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        data = {
            'api': self.api_key,
            'id_get': reference,
            'json': 1
        }
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/gateway-result-second",
                data=data
            ) as response:
                result = await response.json()
                
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ØªÛŒØ¬Ù‡
        if result.get('status') == 1:
            return {
                'success': True,
                'amount': int(result['amount']),
                'factor_id': result['factorId'],
                'reference': result['id_get'],
                'card_number': result.get('cardNumber', 'Ù†Ø§Ù…Ø´Ø®Øµ'),
                'date': result.get('date'),
                'gateway': 'bitpay'
            }
        else:
            error_messages = {
                -1: 'api_key Ù†Ø§Ù…Ø¹ØªØ¨Ø±',
                -2: 'transId ÛŒØ§ÙØª Ù†Ø´Ø¯',
                -3: 'ØªØ±Ø§Ú©Ù†Ø´ Ù‚Ø¨Ù„Ø§Ù‹ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡',
                -4: 'amount Ù†Ø§Ù…Ø·Ø§Ø¨Ù‚',
                2: 'ØªØ±Ø§Ú©Ù†Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯',
                3: 'ØªÙˆÚ©Ù† Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡',
                4: 'Ù…Ø¨Ù„Øº Ù†Ø§Ø¯Ø±Ø³Øª',
                7: 'Ø§Ù†ØµØ±Ø§Ù Ø§Ø² Ù¾Ø±Ø¯Ø§Ø®Øª'
            }
            
            raise PaymentVerificationError(
                error_messages.get(result['status'], 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ø¯Ø± ØªØ§ÛŒÛŒØ¯')
            )
            
    async def refund_payment(
        self,
        reference: str,
        amount: Optional[int] = None
    ) -> Dict:
        """Ø¨Ø§Ø²Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø¯Ø± BitPay"""
        
        # BitPay.ir Ø¨Ø§Ø²Ú¯Ø´Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ù†Ø¯Ø§Ø±Ø¯
        # Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´ÙˆØ¯
        
        return {
            'success': False,
            'message': 'Ø¨Ø§Ø²Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´ÙˆØ¯',
            'manual_refund_required': True
        }
```

### ZarinPal Gateway

```python
# unified_billing/gateways/zarinpal_gateway.py
import aiohttp
from typing import Dict, Optional

class ZarinPalGateway(BasePaymentGateway):
    """Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„"""
    
    def __init__(self, config: Dict):
        super().__init__(config)
        self.merchant_id = config['merchant_id']
        self.base_url = config.get('base_url', 'https://api.zarinpal.com/pg/v4')
        self.callback_url = config['callback_url']
        
    async def create_payment(
        self,
        amount: int,
        order_id: str,
        callback_url: str,
        description: str = "",
        mobile: Optional[str] = None,
        email: Optional[str] = None
    ) -> Dict:
        """Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¯Ø± Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„"""
        
        self.validate_amount(amount)
        
        # ØªØ¨Ø¯ÛŒÙ„ Ø±ÛŒØ§Ù„ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†
        amount_toman = amount // 10
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
        payload = {
            "merchant_id": self.merchant_id,
            "amount": amount_toman,
            "callback_url": callback_url or self.callback_url,
            "description": description or f"Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ {order_id}",
            "metadata": {
                "order_id": order_id,
                "mobile": mobile,
                "email": email
            }
        }
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/payment/request.json",
                json=payload
            ) as response:
                result = await response.json()
                
        # Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§Ø³Ø®
        if result['data']['code'] == 100:
            authority = result['data']['authority']
            return {
                'success': True,
                'payment_url': f"https://www.zarinpal.com/pg/StartPay/{authority}",
                'reference': authority,
                'gateway': 'zarinpal'
            }
        else:
            raise PaymentGatewayError(
                f"Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª: {result['errors']}"
            )
            
    async def verify_payment(
        self,
        reference: str,
        amount: Optional[int] = None
    ) -> Dict:
        """ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„"""
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
        payload = {
            "merchant_id": self.merchant_id,
            "authority": reference,
            "amount": amount // 10 if amount else None
        }
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/payment/verify.json",
                json=payload
            ) as response:
                result = await response.json()
                
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ØªÛŒØ¬Ù‡
        if result['data']['code'] in [100, 101]:
            return {
                'success': True,
                'amount': result['data']['amount'] * 10,  # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ø±ÛŒØ§Ù„
                'reference': reference,
                'ref_id': result['data']['ref_id'],
                'card_pan': result['data']['card_pan'],
                'gateway': 'zarinpal'
            }
        else:
            error_messages = {
                -9: 'Ø®Ø·Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø± Ø³Ù†Ø¬ÛŒ',
                -10: 'Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ØºÛŒØ±ÙØ¹Ø§Ù„',
                -11: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯',
                -12: 'Ø§Ù…Ú©Ø§Ù† ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÛŒØ³Ø± Ù†ÛŒØ³Øª',
                -15: 'ØªØ±Ù…ÛŒÙ†Ø§Ù„ ØºÛŒØ±ÙØ¹Ø§Ù„',
                -16: 'Ø³Ø·Ø­ ØªØ§ÛŒÛŒØ¯ Ù¾Ø°ÛŒØ±Ù†Ø¯Ù‡ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ø³Ø·Ø­ Ù†Ù‚Ø±Ù‡â€ŒØ§ÛŒ',
                -50: 'Ù…Ø¨Ù„Øº Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯Ù‡ Ø¨Ø§ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø¨Ù„Øº Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ù…ØªÙØ§ÙˆØª Ø§Ø³Øª',
                -51: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚',
                -52: 'Ø®Ø·Ø§ÛŒ ØºÛŒØ± Ù…Ù†ØªØ¸Ø±Ù‡',
                -53: 'Ø§ØªÙˆØ±ÛŒØªÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù…Ø±Ú†Ù†Øª Ú©Ø¯ Ù†ÛŒØ³Øª',
                -54: 'Ø§ØªÙˆØ±ÛŒØªÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª'
            }
            
            raise PaymentVerificationError(
                error_messages.get(result['data']['code'], 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡')
            )
```

## ğŸ’¸ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§

### Transaction Model

```python
# unified_billing/models/transaction.py

class Transaction(models.Model):
    """Ù…Ø¯Ù„ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ"""
    
    TRANSACTION_TYPES = [
        ('deposit', 'ÙˆØ§Ø±ÛŒØ²'),
        ('withdrawal', 'Ø¨Ø±Ø¯Ø§Ø´Øª'),
        ('payment', 'Ù¾Ø±Ø¯Ø§Ø®Øª'),
        ('refund', 'Ø¨Ø§Ø²Ú¯Ø´Øª'),
        ('transfer_in', 'Ø§Ù†ØªÙ‚Ø§Ù„ ÙˆØ±ÙˆØ¯ÛŒ'),
        ('transfer_out', 'Ø§Ù†ØªÙ‚Ø§Ù„ Ø®Ø±ÙˆØ¬ÛŒ'),
        ('commission', 'Ú©Ù…ÛŒØ³ÛŒÙˆÙ†'),
        ('subscription', 'Ø§Ø´ØªØ±Ø§Ú©'),
        ('visit_payment', 'Ù¾Ø±Ø¯Ø§Ø®Øª ÙˆÛŒØ²ÛŒØª'),
        ('gift_credit', 'Ø§Ø¹ØªØ¨Ø§Ø± Ù‡Ø¯ÛŒÙ‡'),
    ]
    
    TRANSACTION_STATUS = [
        ('pending', 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±'),
        ('processing', 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´'),
        ('completed', 'ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡'),
        ('failed', 'Ù†Ø§Ù…ÙˆÙÙ‚'),
        ('cancelled', 'Ù„ØºÙˆ Ø´Ø¯Ù‡'),
        ('refunded', 'Ø¨Ø§Ø²Ú¯Ø´Øª Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    wallet = models.ForeignKey(
        Wallet,
        on_delete=models.PROTECT,
        related_name='transactions'
    )
    
    # Ù…Ø´Ø®ØµØ§Øª ØªØ±Ø§Ú©Ù†Ø´
    amount = models.DecimalField(
        max_digits=12,
        decimal_places=0,
        help_text="Ù…Ø¨Ù„Øº Ø¨Ù‡ Ø±ÛŒØ§Ù„ (Ù…Ø«Ø¨Øª: ÙˆØ§Ø±ÛŒØ²ØŒ Ù…Ù†ÙÛŒ: Ø¨Ø±Ø¯Ø§Ø´Øª)"
    )
    type = models.CharField(max_length=20, choices=TRANSACTION_TYPES)
    status = models.CharField(
        max_length=20,
        choices=TRANSACTION_STATUS,
        default='pending'
    )
    
    # Ù…Ø±Ø¬Ø¹
    reference_number = models.CharField(
        max_length=100,
        unique=True,
        db_index=True
    )
    gateway_reference = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        db_index=True
    )
    
    # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª
    gateway = models.CharField(
        max_length=20,
        null=True,
        blank=True,
        choices=[
            ('bitpay', 'BitPay.ir'),
            ('zarinpal', 'ZarinPal'),
            ('idpay', 'IDPay'),
            ('stripe', 'Stripe'),
            ('wallet', 'Ú©ÛŒÙ Ù¾ÙˆÙ„'),
        ]
    )
    
    # Ø±ÙˆØ§Ø¨Ø·
    related_transaction = models.ForeignKey(
        'self',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='related_transactions'
    )
    related_wallet = models.ForeignKey(
        Wallet,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='related_transactions'
    )
    
    # ØªÙˆØ¶ÛŒØ­Ø§Øª
    description = models.TextField(null=True, blank=True)
    metadata = models.JSONField(default=dict)
    
    # Ø²Ù…Ø§Ù†â€ŒÙ‡Ø§
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'transactions'
        indexes = [
            models.Index(fields=['wallet', 'status', 'created_at']),
            models.Index(fields=['type', 'status']),
            models.Index(fields=['reference_number']),
            models.Index(fields=['gateway_reference']),
        ]
        ordering = ['-created_at']
```

### Transaction Service

```python
# unified_billing/services/transaction_service.py

class TransactionService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.audit_logger = AuditLogger()
        self.notification_service = NotificationService()
        
    async def create_transaction(
        self,
        wallet: Wallet,
        amount: Decimal,
        type: str,
        **kwargs
    ) -> Transaction:
        """Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´ Ø¬Ø¯ÛŒØ¯"""
        
        # ØªÙˆÙ„ÛŒØ¯ Ø´Ù…Ø§Ø±Ù‡ Ù…Ø±Ø¬Ø¹ ÛŒÚ©ØªØ§
        reference_number = self._generate_reference_number()
        
        # Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´
        transaction = await Transaction.objects.create(
            wallet=wallet,
            amount=amount,
            type=type,
            reference_number=reference_number,
            status='pending',
            **kwargs
        )
        
        # Ø«Ø¨Øª Ø¯Ø± audit log
        await self.audit_logger.log_transaction_created(transaction)
        
        return transaction
        
    async def complete_transaction(
        self,
        transaction_id: str,
        gateway_reference: Optional[str] = None
    ) -> Transaction:
        """ØªÚ©Ù…ÛŒÙ„ ØªØ±Ø§Ú©Ù†Ø´"""
        
        transaction = await Transaction.objects.select_for_update().get(
            id=transaction_id,
            status='pending'
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        transaction.status = 'completed'
        transaction.completed_at = timezone.now()
        if gateway_reference:
            transaction.gateway_reference = gateway_reference
            
        await transaction.save()
        
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        await self.notification_service.send_transaction_notification(
            transaction
        )
        
        # Ø«Ø¨Øª Ø¯Ø± audit log
        await self.audit_logger.log_transaction_completed(transaction)
        
        return transaction
        
    async def fail_transaction(
        self,
        transaction_id: str,
        reason: str
    ) -> Transaction:
        """Ø«Ø¨Øª Ø´Ú©Ø³Øª ØªØ±Ø§Ú©Ù†Ø´"""
        
        transaction = await Transaction.objects.get(id=transaction_id)
        
        transaction.status = 'failed'
        transaction.metadata['failure_reason'] = reason
        await transaction.save()
        
        # Ø¨Ø§Ø²Ú¯Ø´Øª ØªØºÛŒÛŒØ±Ø§Øª Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
        if transaction.type in ['withdrawal', 'transfer_out']:
            await self._reverse_wallet_changes(transaction)
            
        return transaction
        
    async def get_transaction_report(
        self,
        wallet_id: str,
        start_date: datetime,
        end_date: datetime,
        type: Optional[str] = None
    ) -> Dict:
        """Ú¯Ø²Ø§Ø±Ø´ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§"""
        
        # Query builder
        query = Transaction.objects.filter(
            wallet_id=wallet_id,
            created_at__gte=start_date,
            created_at__lte=end_date,
            status='completed'
        )
        
        if type:
            query = query.filter(type=type)
            
        # Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ
        summary = await query.aggregate(
            total_count=Count('id'),
            total_deposit=Sum('amount', filter=Q(amount__gt=0)),
            total_withdrawal=Sum('amount', filter=Q(amount__lt=0)),
            net_amount=Sum('amount')
        )
        
        # Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹
        by_type = await query.values('type').annotate(
            count=Count('id'),
            total=Sum('amount')
        ).order_by('-total')
        
        # ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
        recent_transactions = await query.order_by('-created_at')[:20]
        
        return {
            'summary': summary,
            'by_type': list(by_type),
            'recent_transactions': [
                self._serialize_transaction(t) for t in recent_transactions
            ],
            'period': {
                'start': start_date.isoformat(),
                'end': end_date.isoformat()
            }
        }
        
    def _generate_reference_number(self) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø´Ù…Ø§Ø±Ù‡ Ù…Ø±Ø¬Ø¹ ÛŒÚ©ØªØ§"""
        
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        random_part = ''.join(random.choices(string.digits, k=6))
        return f"TRX{timestamp}{random_part}"
```

## ğŸ“ˆ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ

### Financial Report Service

```python
# unified_billing/services/report_service.py

class FinancialReportService:
    """Ø³Ø±ÙˆÛŒØ³ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ"""
    
    def __init__(self):
        self.cache = get_redis_client()
        
    async def generate_revenue_report(
        self,
        start_date: datetime,
        end_date: datetime,
        group_by: str = 'day'
    ) -> Dict:
        """Ú¯Ø²Ø§Ø±Ø´ Ø¯Ø±Ø¢Ù…Ø¯"""
        
        # Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ queries
        date_trunc = {
            'day': TruncDay,
            'week': TruncWeek,
            'month': TruncMonth,
            'year': TruncYear
        }
        
        trunc_func = date_trunc.get(group_by, TruncDay)
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ø² Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§
        subscription_revenue = await Transaction.objects.filter(
            type='subscription',
            status='completed',
            created_at__gte=start_date,
            created_at__lte=end_date
        ).annotate(
            period=trunc_func('created_at')
        ).values('period').annotate(
            revenue=Sum('amount'),
            count=Count('id')
        ).order_by('period')
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ø² ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§ (Ú©Ù…ÛŒØ³ÛŒÙˆÙ†)
        visit_commission = await Transaction.objects.filter(
            type='commission',
            status='completed',
            created_at__gte=start_date,
            created_at__lte=end_date
        ).annotate(
            period=trunc_func('created_at')
        ).values('period').annotate(
            revenue=Sum('amount'),
            count=Count('id')
        ).order_by('period')
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ú©Ù„
        total_revenue = await Transaction.objects.filter(
            type__in=['subscription', 'commission'],
            status='completed',
            created_at__gte=start_date,
            created_at__lte=end_date
        ).aggregate(
            total=Sum('amount'),
            count=Count('id')
        )
        
        return {
            'subscription_revenue': list(subscription_revenue),
            'visit_commission': list(visit_commission),
            'total_revenue': total_revenue,
            'period': {
                'start': start_date.isoformat(),
                'end': end_date.isoformat(),
                'group_by': group_by
            }
        }
        
    async def generate_user_growth_report(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> Dict:
        """Ú¯Ø²Ø§Ø±Ø´ Ø±Ø´Ø¯ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"""
        
        # Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¬Ø¯ÛŒØ¯
        new_users = await UnifiedUser.objects.filter(
            created_at__gte=start_date,
            created_at__lte=end_date
        ).values('user_type').annotate(
            count=Count('id')
        )
        
        # Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
        new_subscriptions = await Subscription.objects.filter(
            created_at__gte=start_date,
            created_at__lte=end_date
        ).values('plan__type').annotate(
            count=Count('id')
        )
        
        # Ù†Ø±Ø® ØªØ¨Ø¯ÛŒÙ„
        trial_to_paid = await self._calculate_conversion_rate(
            start_date, end_date
        )
        
        return {
            'new_users': list(new_users),
            'new_subscriptions': list(new_subscriptions),
            'conversion_rate': trial_to_paid,
            'period': {
                'start': start_date.isoformat(),
                'end': end_date.isoformat()
            }
        }
        
    async def generate_payment_gateway_report(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> Dict:
        """Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª"""
        
        gateway_stats = await Transaction.objects.filter(
            type='payment',
            created_at__gte=start_date,
            created_at__lte=end_date
        ).values('gateway', 'status').annotate(
            count=Count('id'),
            total_amount=Sum('amount')
        ).order_by('gateway', 'status')
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª
        gateway_success_rate = {}
        for gateway in ['bitpay', 'zarinpal', 'idpay']:
            total = sum(
                s['count'] for s in gateway_stats
                if s['gateway'] == gateway
            )
            successful = sum(
                s['count'] for s in gateway_stats
                if s['gateway'] == gateway and s['status'] == 'completed'
            )
            
            if total > 0:
                gateway_success_rate[gateway] = {
                    'total': total,
                    'successful': successful,
                    'rate': (successful / total) * 100
                }
                
        return {
            'gateway_stats': list(gateway_stats),
            'success_rates': gateway_success_rate,
            'period': {
                'start': start_date.isoformat(),
                'end': end_date.isoformat()
            }
        }
```

### Dashboard Service

```python
# unified_billing/services/dashboard_service.py

class FinancialDashboardService:
    """Ø³Ø±ÙˆÛŒØ³ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø§Ù„ÛŒ"""
    
    async def get_admin_dashboard_data(self) -> Dict:
        """Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø§Ø¯Ù…ÛŒÙ†"""
        
        now = timezone.now()
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ù…Ø±ÙˆØ²
        today_revenue = await Transaction.objects.filter(
            type__in=['subscription', 'commission'],
            status='completed',
            created_at__gte=today_start
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ù…Ø§Ù‡
        month_revenue = await Transaction.objects.filter(
            type__in=['subscription', 'commission'],
            status='completed',
            created_at__gte=month_start
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        # Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„
        active_subscriptions = await Subscription.objects.filter(
            status='active'
        ).count()
        
        # ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ù…Ø±ÙˆØ²
        today_transactions = await Transaction.objects.filter(
            created_at__gte=today_start
        ).count()
        
        # Ù†Ù…ÙˆØ¯Ø§Ø± Ø¯Ø±Ø¢Ù…Ø¯ 30 Ø±ÙˆØ² Ø§Ø®ÛŒØ±
        revenue_chart = await self._get_revenue_chart_data(30)
        
        # ØªÙˆØ²ÛŒØ¹ Ù¾Ù„Ù†â€ŒÙ‡Ø§
        plan_distribution = await Subscription.objects.filter(
            status='active'
        ).values('plan__name').annotate(
            count=Count('id')
        ).order_by('-count')
        
        return {
            'summary': {
                'today_revenue': today_revenue,
                'month_revenue': month_revenue,
                'active_subscriptions': active_subscriptions,
                'today_transactions': today_transactions
            },
            'charts': {
                'revenue_trend': revenue_chart,
                'plan_distribution': list(plan_distribution)
            }
        }
        
    async def get_doctor_financial_summary(
        self,
        doctor_id: str
    ) -> Dict:
        """Ø®Ù„Ø§ØµÙ‡ Ù…Ø§Ù„ÛŒ Ù¾Ø²Ø´Ú©"""
        
        now = timezone.now()
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        # Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù¾Ø²Ø´Ú©
        wallet = await Wallet.objects.get(user_id=doctor_id)
        
        # Ø¯Ø±Ø¢Ù…Ø¯ Ù…Ø§Ù‡ Ø¬Ø§Ø±ÛŒ
        month_income = await Transaction.objects.filter(
            wallet=wallet,
            type='visit_payment',
            status='completed',
            created_at__gte=month_start
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        # ØªØ¹Ø¯Ø§Ø¯ ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù‡
        visit_count = await Transaction.objects.filter(
            wallet=wallet,
            type='visit_payment',
            status='completed',
            created_at__gte=month_start
        ).count()
        
        # Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¯Ø±Ø¢Ù…Ø¯ Ù‡Ø± ÙˆÛŒØ²ÛŒØª
        avg_visit_income = month_income / visit_count if visit_count > 0 else 0
        
        # ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
        recent_transactions = await Transaction.objects.filter(
            wallet=wallet
        ).order_by('-created_at')[:10]
        
        return {
            'wallet': {
                'balance': wallet.balance,
                'available': wallet.available_balance
            },
            'current_month': {
                'income': month_income,
                'visits': visit_count,
                'average': avg_visit_income
            },
            'recent_transactions': [
                self._serialize_transaction(t) for t in recent_transactions
            ]
        }
```

## ğŸ” Ø§Ù…Ù†ÛŒØª Ù…Ø§Ù„ÛŒ

### Payment Security Service

```python
# unified_billing/services/security_service.py

class PaymentSecurityService:
    """Ø³Ø±ÙˆÛŒØ³ Ø§Ù…Ù†ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.fraud_detector = FraudDetector()
        self.encryptor = PaymentEncryptor()
        self.audit_logger = AuditLogger()
        
    async def validate_payment_request(
        self,
        user_id: str,
        amount: Decimal,
        payment_method: str,
        ip_address: str
    ) -> Dict:
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª"""
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
        user = await UnifiedUser.objects.get(id=user_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯Ù† Ø­Ø³Ø§Ø¨
        if not user.is_active:
            raise PaymentSecurityError("Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª")
            
        # Ø¨Ø±Ø±Ø³ÛŒ ØªØ§ÛŒÛŒØ¯ Ù‡ÙˆÛŒØª Ø¨Ø±Ø§ÛŒ Ù…Ø¨Ø§Ù„Øº Ø¨Ø§Ù„Ø§
        if amount > 10000000 and not user.is_verified:
            raise PaymentSecurityError(
                "Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ù…Ø¨Ø§Ù„Øº Ø¨Ø§Ù„Ø§ÛŒ 10 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø±ÛŒØ§Ù„ØŒ ØªØ§ÛŒÛŒØ¯ Ù‡ÙˆÛŒØª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
            )
            
        # ØªØ´Ø®ÛŒØµ ØªÙ‚Ù„Ø¨
        fraud_check = await self.fraud_detector.check_payment(
            user_id=user_id,
            amount=amount,
            ip_address=ip_address,
            payment_method=payment_method
        )
        
        if fraud_check['risk_level'] == 'high':
            # Ø«Ø¨Øª Ø¯Ø± Ù„Ø§Ú¯
            await self.audit_logger.log_suspicious_payment(
                user_id, amount, fraud_check['reasons']
            )
            
            # Ø¨Ù„ÙˆÚ©Ù‡ Ú©Ø±Ø¯Ù† Ù¾Ø±Ø¯Ø§Ø®Øª
            raise PaymentSecurityError(
                "Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ù‡ Ø¯Ù„Ø§ÛŒÙ„ Ø§Ù…Ù†ÛŒØªÛŒ Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯"
            )
            
        return {
            'validated': True,
            'risk_level': fraud_check['risk_level'],
            'require_2fa': fraud_check['risk_level'] == 'medium'
        }
        
    async def encrypt_sensitive_data(
        self,
        data: Dict
    ) -> Dict:
        """Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³"""
        
        sensitive_fields = ['card_number', 'cvv', 'account_number']
        encrypted_data = data.copy()
        
        for field in sensitive_fields:
            if field in data:
                encrypted_data[field] = await self.encryptor.encrypt(
                    data[field]
                )
                
        return encrypted_data
```

### Fraud Detection

```python
# unified_billing/services/fraud_detector.py

class FraudDetector:
    """Ø³ÛŒØ³ØªÙ… ØªØ´Ø®ÛŒØµ ØªÙ‚Ù„Ø¨"""
    
    def __init__(self):
        self.rules = self._load_fraud_rules()
        self.ml_model = self._load_ml_model()
        
    async def check_payment(
        self,
        user_id: str,
        amount: Decimal,
        ip_address: str,
        payment_method: str
    ) -> Dict:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ ØªÙ‚Ù„Ø¨"""
        
        risk_factors = []
        risk_score = 0
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù„Ú¯ÙˆÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª
        pattern_check = await self._check_payment_pattern(
            user_id, amount
        )
        if pattern_check['suspicious']:
            risk_factors.append(pattern_check['reason'])
            risk_score += pattern_check['score']
            
        # Ø¨Ø±Ø±Ø³ÛŒ IP
        ip_check = await self._check_ip_reputation(ip_address)
        if ip_check['suspicious']:
            risk_factors.append(ip_check['reason'])
            risk_score += ip_check['score']
            
        # Ø¨Ø±Ø±Ø³ÛŒ velocity
        velocity_check = await self._check_velocity(user_id)
        if velocity_check['suspicious']:
            risk_factors.append(velocity_check['reason'])
            risk_score += velocity_check['score']
            
        # ØªØ­Ù„ÛŒÙ„ ML
        if self.ml_model:
            ml_score = await self._ml_analysis(
                user_id, amount, ip_address, payment_method
            )
            risk_score += ml_score
            
        # ØªØ¹ÛŒÛŒÙ† Ø³Ø·Ø­ Ø±ÛŒØ³Ú©
        risk_level = self._determine_risk_level(risk_score)
        
        return {
            'risk_level': risk_level,
            'risk_score': risk_score,
            'reasons': risk_factors,
            'timestamp': datetime.utcnow().isoformat()
        }
        
    async def _check_payment_pattern(
        self,
        user_id: str,
        amount: Decimal
    ) -> Dict:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù„Ú¯ÙˆÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ø±Ø¨Ø±"""
        
        # Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
        avg_payment = await Transaction.objects.filter(
            wallet__user_id=user_id,
            type='payment',
            status='completed'
        ).aggregate(avg=Avg('amount'))['avg'] or 0
        
        # Ø§Ú¯Ø± Ù…Ø¨Ù„Øº Ø¨ÛŒØ´ Ø§Ø² 3 Ø¨Ø±Ø§Ø¨Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ø§Ø´Ø¯
        if avg_payment > 0 and amount > avg_payment * 3:
            return {
                'suspicious': True,
                'reason': f'Ù…Ø¨Ù„Øº Ù¾Ø±Ø¯Ø§Ø®Øª {amount/avg_payment:.1f} Ø¨Ø±Ø§Ø¨Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†',
                'score': 30
            }
            
        return {'suspicious': False, 'score': 0}
```

---

[ELEMENT: div align="center"]

[â†’ Ù‚Ø¨Ù„ÛŒ: Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ](06-ai-systems.md) | [Ø¨Ø¹Ø¯ÛŒ: ÙˆÛŒØ²ÛŒØª Ùˆ Ù…Ù„Ø§Ù‚Ø§Øªâ€ŒÙ‡Ø§ â†](08-visits-encounters.md)

</div>
