# ğŸ¥ ÙˆÛŒØ²ÛŒØª Ùˆ Ù…Ù„Ø§Ù‚Ø§Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ HELSSA

## ğŸ“‹ ÙÙ‡Ø±Ø³Øª Ù…Ø·Ø§Ù„Ø¨

- [Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… ÙˆÛŒØ²ÛŒØª](## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… ÙˆÛŒØ²ÛŒØª)
- [Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ù„Ø§Ù‚Ø§Øª](## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ù„Ø§Ù‚Ø§Øª)
- [Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡](## ğŸ“Š Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡)
- [Ø¬Ø±ÛŒØ§Ù† ÙˆÛŒØ²ÛŒØª Ø¢Ù†Ù„Ø§ÛŒÙ†](## ğŸ”„ Ø¬Ø±ÛŒØ§Ù† ÙˆÛŒØ²ÛŒØª Ø¢Ù†Ù„Ø§ÛŒÙ†)
- [Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª ÙˆÛŒØ²ÛŒØª](## ğŸ™ï¸ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª ÙˆÛŒØ²ÛŒØª)
- [ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP](## ğŸ“ ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP)
- [Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§](## ğŸ“‚ Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§)
- [Ø§Ù…Ù†ÛŒØª Ùˆ Ø­Ø±ÛŒÙ… Ø®ØµÙˆØµÛŒ](## ğŸ”’ Ø§Ù…Ù†ÛŒØª Ùˆ Ø­Ø±ÛŒÙ… Ø®ØµÙˆØµÛŒ)

---

## ğŸ¯ Ù…Ø¹Ø±ÙÛŒ Ø³ÛŒØ³ØªÙ… ÙˆÛŒØ²ÛŒØª

Ø³ÛŒØ³ØªÙ… ÙˆÛŒØ²ÛŒØª HELSSA ÛŒÚ© Ù¾Ù„ØªÙØ±Ù… Ø¬Ø§Ù…Ø¹ Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù„Ø§Ù‚Ø§Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø§Ù…Ú©Ø§Ù† ÙˆÛŒØ²ÛŒØª Ø­Ø¶ÙˆØ±ÛŒØŒ Ø¢Ù†Ù„Ø§ÛŒÙ†ØŒ Ø¶Ø¨Ø· ØµÙˆØªØŒ Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ SOAP Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯.

### ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ

- ğŸ¥ **ÙˆÛŒØ²ÛŒØª ÙˆÛŒØ¯ÛŒÙˆÛŒÛŒ** Ø¨Ø§ Ú©ÛŒÙÛŒØª HD
- ğŸ™ï¸ **Ø¶Ø¨Ø· Ø®ÙˆØ¯Ú©Ø§Ø± ØµÙˆØª** Ù…Ù„Ø§Ù‚Ø§Øªâ€ŒÙ‡Ø§
- ğŸ“ **Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯** Ø¨Ø§ Whisper
- ğŸ“Š **ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP** Ø®ÙˆØ¯Ú©Ø§Ø±
- ğŸ“ **Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±ÙˆÙ†Ø¯Ù‡** Ø¨ÛŒÙ…Ø§Ø±Ø§Ù†
- â° **Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯** ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§
- ğŸ’Š **Ù†Ø³Ø®Ù‡â€ŒÙ†ÙˆÛŒØ³ÛŒ Ø§Ù„Ú©ØªØ±ÙˆÙ†ÛŒÚ©**

## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ù„Ø§Ù‚Ø§Øª

```mermaid
graph TB
    subgraph "Client Layer"
        PWA[Patient Web App]
        DWA[Doctor Web App]
        MOB[Mobile Apps]
    end
    
    subgraph "Video/Audio Infrastructure"
        TURN[TURN Server]
        REC[Recording Service]
        TRANS[Transcoding Service]
    end
    
    subgraph "Visit Management Core"
        VSM[Visit Service Manager]
        SCH[Scheduling Service]
        QUE[Queue Manager]
        NOT[Notification Service]
    end
    
    subgraph "Audio Processing Pipeline"
        AUD[Audio Uploader]
        CHK[Chunking Service]
        STT[STT Service]
        MRG[Merge Service]
    end
    
    subgraph "Report Generation"
        NLP[NLP Processor]
        SOAP[SOAP Generator]
        PDF[PDF Generator]
        SIGN[Digital Signature]
    end
    
    subgraph "Data Storage"
        DB[(Encounter DB)]
        MINIO[(MinIO Storage)]
        CACHE[(Redis Cache)]
    end
    
    PWA --> VSM
    DWA --> VSM
    MOB --> VSM
    
    VSM --> SCH
    VSM --> QUE
    VSM --> NOT
    
    REC --> AUD
    AUD --> CHK
    CHK --> STT
    STT --> MRG
    
    MRG --> NLP
    NLP --> SOAP
    SOAP --> PDF
    PDF --> SIGN
    
    All --> DB
    AUD --> MINIO
    STT --> CACHE
```

### Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Encounters

```python
encounters/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ encounter.py            # Ù…Ø¯Ù„ Ù…Ù„Ø§Ù‚Ø§Øª
â”‚   â”œâ”€â”€ audio_chunk.py          # Ù…Ø¯Ù„ Ù‚Ø·Ø¹Ø§Øª ØµÙˆØªÛŒ
â”‚   â”œâ”€â”€ transcript.py           # Ù…Ø¯Ù„ Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ
â”‚   â”œâ”€â”€ soap_report.py          # Ù…Ø¯Ù„ Ú¯Ø²Ø§Ø±Ø´ SOAP
â”‚   â””â”€â”€ prescription.py         # Ù…Ø¯Ù„ Ù†Ø³Ø®Ù‡
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ visit_manager.py        # Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒØ²ÛŒØª
â”‚   â”œâ”€â”€ scheduling_service.py   # Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ
â”‚   â”œâ”€â”€ audio_processor.py      # Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª
â”‚   â”œâ”€â”€ soap_generator.py       # ØªÙˆÙ„ÛŒØ¯ SOAP
â”‚   â””â”€â”€ video_service.py        # Ø³Ø±ÙˆÛŒØ³ ÙˆÛŒØ¯ÛŒÙˆ
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ serializers.py
â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”œâ”€â”€ encounter_views.py
â”‚   â”‚   â”œâ”€â”€ audio_views.py
â”‚   â”‚   â””â”€â”€ report_views.py
â”‚   â””â”€â”€ permissions.py
â”œâ”€â”€ tasks.py                     # Celery tasks
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ audio_utils.py
â”‚   â”œâ”€â”€ encryption.py
â”‚   â””â”€â”€ validators.py
â””â”€â”€ migrations/
```

## ğŸ“Š Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡

### Encounter Model

```python
# encounters/models/encounter.py
from django.db import models
import uuid
from datetime import timedelta

class Encounter(models.Model):
    """Ù…Ø¯Ù„ Ù…Ù„Ø§Ù‚Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ"""
    
    ENCOUNTER_TYPES = [
        ('in_person', 'Ø­Ø¶ÙˆØ±ÛŒ'),
        ('video', 'ÙˆÛŒØ¯ÛŒÙˆÛŒÛŒ'),
        ('audio', 'ØµÙˆØªÛŒ'),
        ('chat', 'Ú†Øª'),
        ('follow_up', 'Ù¾ÛŒÚ¯ÛŒØ±ÛŒ'),
    ]
    
    ENCOUNTER_STATUS = [
        ('scheduled', 'Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ø´Ø¯Ù‡'),
        ('confirmed', 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡'),
        ('in_progress', 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…'),
        ('completed', 'ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡'),
        ('cancelled', 'Ù„ØºÙˆ Ø´Ø¯Ù‡'),
        ('no_show', 'Ø¹Ø¯Ù… Ø­Ø¶ÙˆØ±'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    
    # Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ú¯Ø§Ù†
    patient = models.ForeignKey(
        'unified_auth.UnifiedUser',
        on_delete=models.PROTECT,
        related_name='patient_encounters'
    )
    doctor = models.ForeignKey(
        'unified_auth.UnifiedUser',
        on_delete=models.PROTECT,
        related_name='doctor_encounters'
    )
    
    # Ù…Ø´Ø®ØµØ§Øª ÙˆÛŒØ²ÛŒØª
    type = models.CharField(max_length=20, choices=ENCOUNTER_TYPES)
    status = models.CharField(
        max_length=20,
        choices=ENCOUNTER_STATUS,
        default='scheduled'
    )
    chief_complaint = models.TextField(
        help_text="Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ Ø¨ÛŒÙ…Ø§Ø±"
    )
    
    # Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ
    scheduled_at = models.DateTimeField()
    duration_minutes = models.IntegerField(default=30)
    started_at = models.DateTimeField(null=True, blank=True)
    ended_at = models.DateTimeField(null=True, blank=True)
    
    # Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ Ùˆ Ø¯Ø³ØªØ±Ø³ÛŒ
    video_room_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        help_text="ID Ø§ØªØ§Ù‚ ÙˆÛŒØ¯ÛŒÙˆ"
    )
    patient_join_url = models.URLField(null=True, blank=True)
    doctor_join_url = models.URLField(null=True, blank=True)
    
    # Ø¶Ø¨Ø·
    is_recording_enabled = models.BooleanField(default=True)
    recording_consent = models.BooleanField(default=False)
    recording_url = models.URLField(null=True, blank=True)
    
    # Ù¾Ø±Ø¯Ø§Ø®Øª
    fee_amount = models.DecimalField(
        max_digits=10,
        decimal_places=0,
        help_text="Ù‡Ø²ÛŒÙ†Ù‡ ÙˆÛŒØ²ÛŒØª Ø¨Ù‡ Ø±ÛŒØ§Ù„"
    )
    is_paid = models.BooleanField(default=False)
    payment_transaction = models.ForeignKey(
        'unified_billing.Transaction',
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )
    
    # ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§
    patient_notes = models.TextField(
        null=True,
        blank=True,
        help_text="ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø± Ù‚Ø¨Ù„ Ø§Ø² ÙˆÛŒØ²ÛŒØª"
    )
    doctor_notes = models.TextField(
        null=True,
        blank=True,
        help_text="ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©"
    )
    
    # Ø§Ù…Ù†ÛŒØª
    access_code = models.CharField(
        max_length=6,
        null=True,
        blank=True,
        help_text="Ú©Ø¯ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø±"
    )
    encryption_key = models.CharField(
        max_length=255,
        help_text="Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§"
    )
    
    # metadata
    metadata = models.JSONField(default=dict)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'encounters'
        indexes = [
            models.Index(fields=['patient', 'status', 'scheduled_at']),
            models.Index(fields=['doctor', 'status', 'scheduled_at']),
            models.Index(fields=['scheduled_at']),
            models.Index(fields=['video_room_id']),
        ]
        ordering = ['-scheduled_at']
        
    @property
    def actual_duration(self) -> timedelta:
        """Ù…Ø¯Øª Ø²Ù…Ø§Ù† ÙˆØ§Ù‚Ø¹ÛŒ ÙˆÛŒØ²ÛŒØª"""
        if self.started_at and self.ended_at:
            return self.ended_at - self.started_at
        return timedelta(minutes=self.duration_minutes)
        
    @property
    def is_upcoming(self) -> bool:
        """Ø¢ÛŒØ§ ÙˆÛŒØ²ÛŒØª Ø¯Ø± Ø¢ÛŒÙ†Ø¯Ù‡ Ø§Ø³Øª"""
        return self.scheduled_at > timezone.now() and self.status == 'scheduled'
```

### AudioChunk Model

```python
# encounters/models/audio_chunk.py

class AudioChunk(models.Model):
    """Ù…Ø¯Ù„ Ù‚Ø·Ø¹Ø§Øª ØµÙˆØªÛŒ Ø¶Ø¨Ø· Ø´Ø¯Ù‡"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    encounter = models.ForeignKey(
        Encounter,
        on_delete=models.CASCADE,
        related_name='audio_chunks'
    )
    
    # Ù…Ø´Ø®ØµØ§Øª ÙØ§ÛŒÙ„
    chunk_index = models.IntegerField(
        help_text="Ø´Ù…Ø§Ø±Ù‡ ØªØ±ØªÛŒØ¨ÛŒ Ù‚Ø·Ø¹Ù‡"
    )
    file_url = models.URLField(
        help_text="Ø¢Ø¯Ø±Ø³ ÙØ§ÛŒÙ„ Ø¯Ø± MinIO"
    )
    file_size = models.IntegerField(
        help_text="Ø­Ø¬Ù… ÙØ§ÛŒÙ„ Ø¨Ù‡ Ø¨Ø§ÛŒØª"
    )
    duration_seconds = models.FloatField(
        help_text="Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ù‚Ø·Ø¹Ù‡ Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡"
    )
    
    # ÙØ±Ù…Øª Ùˆ Ú©ÛŒÙÛŒØª
    format = models.CharField(
        max_length=10,
        default='webm',
        choices=[
            ('webm', 'WebM'),
            ('mp3', 'MP3'),
            ('wav', 'WAV'),
            ('ogg', 'OGG'),
        ]
    )
    sample_rate = models.IntegerField(default=48000)
    bit_rate = models.IntegerField(null=True, blank=True)
    
    # ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´
    is_processed = models.BooleanField(default=False)
    transcription_status = models.CharField(
        max_length=20,
        choices=[
            ('pending', 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±'),
            ('processing', 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´'),
            ('completed', 'ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡'),
            ('failed', 'Ù†Ø§Ù…ÙˆÙÙ‚'),
        ],
        default='pending'
    )
    
    # Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ
    is_encrypted = models.BooleanField(default=True)
    encryption_metadata = models.JSONField(
        default=dict,
        help_text="Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ"
    )
    
    # Ø²Ù…Ø§Ù†â€ŒÙ‡Ø§
    recorded_at = models.DateTimeField(auto_now_add=True)
    processed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'audio_chunks'
        unique_together = [['encounter', 'chunk_index']]
        ordering = ['encounter', 'chunk_index']
```

### Transcript Model

```python
# encounters/models/transcript.py

class Transcript(models.Model):
    """Ù…Ø¯Ù„ Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ ØµÙˆØª"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    audio_chunk = models.OneToOneField(
        AudioChunk,
        on_delete=models.CASCADE,
        related_name='transcript'
    )
    
    # Ù…ØªÙ† Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ
    text = models.TextField(
        help_text="Ù…ØªÙ† Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ø´Ø¯Ù‡"
    )
    language = models.CharField(
        max_length=5,
        default='fa',
        help_text="Ø²Ø¨Ø§Ù† ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡"
    )
    
    # Ú©ÛŒÙÛŒØª Ùˆ Ø¯Ù‚Øª
    confidence_score = models.FloatField(
        default=0.0,
        help_text="Ø§Ù…ØªÛŒØ§Ø² Ø§Ø·Ù…ÛŒÙ†Ø§Ù† (0-1)"
    )
    word_timestamps = models.JSONField(
        default=list,
        help_text="Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ù„Ù…Ø§Øª"
    )
    
    # Speaker Diarization
    speakers = models.JSONField(
        default=dict,
        help_text="ØªØ´Ø®ÛŒØµ Ú¯ÙˆÛŒÙ†Ø¯Ù‡â€ŒÙ‡Ø§"
    )
    
    # Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
    medical_entities = models.JSONField(
        default=dict,
        help_text="Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø´Ø¯Ù‡"
    )
    corrections = models.JSONField(
        default=list,
        help_text="Ø§ØµÙ„Ø§Ø­Ø§Øª Ø¯Ø³ØªÛŒ"
    )
    
    # metadata
    stt_model = models.CharField(
        max_length=50,
        default='whisper-1'
    )
    processing_time = models.FloatField(
        null=True,
        blank=True,
        help_text="Ø²Ù…Ø§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'transcripts'
        indexes = [
            models.Index(fields=['audio_chunk', 'language']),
        ]
```

### SOAPReport Model

```python
# encounters/models/soap_report.py

class SOAPReport(models.Model):
    """Ù…Ø¯Ù„ Ú¯Ø²Ø§Ø±Ø´ SOAP"""
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    encounter = models.OneToOneField(
        Encounter,
        on_delete=models.CASCADE,
        related_name='soap_report'
    )
    
    # Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ SOAP
    subjective = models.TextField(
        help_text="Subjective - Ø´Ø±Ø­ Ø­Ø§Ù„ Ùˆ Ø¹Ù„Ø§Ø¦Ù… Ø¨ÛŒÙ…Ø§Ø±"
    )
    objective = models.TextField(
        help_text="Objective - ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§ÛŒÙ†Ù‡ Ùˆ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª"
    )
    assessment = models.TextField(
        help_text="Assessment - Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ùˆ ØªØ´Ø®ÛŒØµ"
    )
    plan = models.TextField(
        help_text="Plan - Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¯Ø±Ù…Ø§Ù†"
    )
    
    # Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³Ø§Ø®ØªØ§Ø±ÛŒØ§ÙØªÙ‡
    diagnoses = models.JSONField(
        default=list,
        help_text="Ù„ÛŒØ³Øª ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ Ø¨Ø§ Ú©Ø¯ ICD"
    )
    medications = models.JSONField(
        default=list,
        help_text="Ø¯Ø§Ø±ÙˆÙ‡Ø§ÛŒ ØªØ¬ÙˆÛŒØ² Ø´Ø¯Ù‡"
    )
    lab_orders = models.JSONField(
        default=list,
        help_text="Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø¢Ø²Ù…Ø§ÛŒØ´"
    )
    follow_up = models.JSONField(
        default=dict,
        help_text="Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ"
    )
    
    # ØªØ§ÛŒÛŒØ¯ÛŒÙ‡â€ŒÙ‡Ø§
    is_draft = models.BooleanField(default=True)
    doctor_approved = models.BooleanField(default=False)
    doctor_approved_at = models.DateTimeField(null=True, blank=True)
    patient_shared = models.BooleanField(default=False)
    patient_shared_at = models.DateTimeField(null=True, blank=True)
    
    # Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„
    doctor_signature = models.TextField(
        null=True,
        blank=True,
        help_text="Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù¾Ø²Ø´Ú©"
    )
    signature_timestamp = models.DateTimeField(null=True, blank=True)
    
    # Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§
    pdf_url = models.URLField(
        null=True,
        blank=True,
        help_text="Ø¢Ø¯Ø±Ø³ ÙØ§ÛŒÙ„ PDF"
    )
    markdown_content = models.TextField(
        null=True,
        blank=True,
        help_text="Ù…Ø­ØªÙˆØ§ÛŒ Markdown"
    )
    
    # metadata
    generation_method = models.CharField(
        max_length=20,
        choices=[
            ('ai', 'ØªÙˆÙ„ÛŒØ¯ Ø¨Ø§ AI'),
            ('manual', 'Ø¯Ø³ØªÛŒ'),
            ('hybrid', 'ØªØ±Ú©ÛŒØ¨ÛŒ'),
        ],
        default='ai'
    )
    ai_confidence = models.FloatField(
        null=True,
        blank=True,
        help_text="Ø§Ù…ØªÛŒØ§Ø² Ø§Ø·Ù…ÛŒÙ†Ø§Ù† AI"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'soap_reports'
```

## ğŸ”„ Ø¬Ø±ÛŒØ§Ù† ÙˆÛŒØ²ÛŒØª Ø¢Ù†Ù„Ø§ÛŒÙ†

### Visit Scheduling Service

```python
# encounters/services/scheduling_service.py
from datetime import datetime, timedelta
from typing import Dict, List, Optional

class VisitSchedulingService:
    """Ø³Ø±ÙˆÛŒØ³ Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.notification_service = NotificationService()
        self.payment_service = PaymentService()
        self.video_service = VideoConferenceService()
        
    async def schedule_visit(
        self,
        patient_id: str,
        doctor_id: str,
        visit_type: str,
        scheduled_at: datetime,
        duration_minutes: int = 30,
        chief_complaint: str = "",
        notes: Optional[str] = None
    ) -> Encounter:
        """Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ ÙˆÛŒØ²ÛŒØª Ø¬Ø¯ÛŒØ¯"""
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ø¨ÙˆØ¯Ù† Ù¾Ø²Ø´Ú©
        if not await self._check_doctor_availability(
            doctor_id, scheduled_at, duration_minutes
        ):
            raise SchedulingConflictError(
                "Ù¾Ø²Ø´Ú© Ø¯Ø± Ø§ÛŒÙ† Ø²Ù…Ø§Ù† Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª"
            )
            
        # Ø¨Ø±Ø±Ø³ÛŒ ØªØ¯Ø§Ø®Ù„ Ø¨Ø§ ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨ÛŒÙ…Ø§Ø±
        if await self._has_patient_conflict(
            patient_id, scheduled_at, duration_minutes
        ):
            raise SchedulingConflictError(
                "Ø´Ù…Ø§ Ø¯Ø± Ø§ÛŒÙ† Ø²Ù…Ø§Ù† ÙˆÛŒØ²ÛŒØª Ø¯ÛŒÚ¯Ø±ÛŒ Ø¯Ø§Ø±ÛŒØ¯"
            )
            
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ ÙˆÛŒØ²ÛŒØª
        doctor = await UnifiedUser.objects.get(id=doctor_id)
        fee_amount = await self._calculate_visit_fee(
            doctor, visit_type, duration_minutes
        )
        
        # Ø§ÛŒØ¬Ø§Ø¯ encounter
        encounter = await Encounter.objects.create(
            patient_id=patient_id,
            doctor_id=doctor_id,
            type=visit_type,
            scheduled_at=scheduled_at,
            duration_minutes=duration_minutes,
            chief_complaint=chief_complaint,
            patient_notes=notes,
            fee_amount=fee_amount,
            encryption_key=self._generate_encryption_key()
        )
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚ ÙˆÛŒØ¯ÛŒÙˆ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¢Ù†Ù„Ø§ÛŒÙ†
        if visit_type in ['video', 'audio']:
            video_room = await self.video_service.create_room(
                encounter_id=str(encounter.id),
                scheduled_at=scheduled_at,
                duration_minutes=duration_minutes
            )
            
            encounter.video_room_id = video_room['room_id']
            encounter.patient_join_url = video_room['patient_url']
            encounter.doctor_join_url = video_room['doctor_url']
            await encounter.save()
            
        # Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
        await self._send_scheduling_notifications(encounter)
        
        # ØªÙ†Ø¸ÛŒÙ… ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒâ€ŒÙ‡Ø§
        await self._schedule_reminders(encounter)
        
        return encounter
        
    async def confirm_visit(
        self,
        encounter_id: str,
        confirmed_by: str
    ) -> Encounter:
        """ØªØ§ÛŒÛŒØ¯ ÙˆÛŒØ²ÛŒØª"""
        
        encounter = await Encounter.objects.get(
            id=encounter_id,
            status='scheduled'
        )
        
        # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾Ø±Ø¯Ø§Ø®Øª
        if not encounter.is_paid:
            payment = await self.payment_service.process_visit_payment(
                encounter.patient,
                encounter.fee_amount,
                encounter_id
            )
            
            encounter.is_paid = True
            encounter.payment_transaction = payment
            
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        encounter.status = 'confirmed'
        encounter.metadata['confirmed_by'] = confirmed_by
        encounter.metadata['confirmed_at'] = datetime.utcnow().isoformat()
        await encounter.save()
        
        # Ø§Ø±Ø³Ø§Ù„ ØªØ§ÛŒÛŒØ¯ÛŒÙ‡
        await self._send_confirmation_notifications(encounter)
        
        return encounter
        
    async def start_visit(
        self,
        encounter_id: str,
        started_by: str
    ) -> Dict:
        """Ø´Ø±ÙˆØ¹ ÙˆÛŒØ²ÛŒØª"""
        
        encounter = await Encounter.objects.get(
            id=encounter_id,
            status='confirmed'
        )
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø²Ù…Ø§Ù†
        now = timezone.now()
        scheduled_time = encounter.scheduled_at
        
        # Ø§Ø¬Ø§Ø²Ù‡ Ø´Ø±ÙˆØ¹ Ø§Ø² 10 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù‚Ø¨Ù„
        if now < scheduled_time - timedelta(minutes=10):
            raise EarlyStartError(
                f"ÙˆÛŒØ²ÛŒØª Ø§Ø² {scheduled_time} Ù‚Ø§Ø¨Ù„ Ø´Ø±ÙˆØ¹ Ø§Ø³Øª"
            )
            
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        encounter.status = 'in_progress'
        encounter.started_at = now
        await encounter.save()
        
        # Ø´Ø±ÙˆØ¹ Ø¶Ø¨Ø· Ø¯Ø± ØµÙˆØ±Øª Ø±Ø¶Ø§ÛŒØª
        if encounter.recording_consent:
            await self._start_recording(encounter)
            
        # Ø¨Ø§Ø²Ú¯Ø´Øª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§ØªØµØ§Ù„
        return {
            'encounter_id': str(encounter.id),
            'video_room_id': encounter.video_room_id,
            'join_url': (
                encounter.doctor_join_url 
                if started_by == str(encounter.doctor_id)
                else encounter.patient_join_url
            ),
            'recording_enabled': encounter.is_recording_enabled,
            'estimated_end_time': now + timedelta(
                minutes=encounter.duration_minutes
            )
        }
        
    async def end_visit(
        self,
        encounter_id: str,
        ended_by: str
    ) -> Encounter:
        """Ù¾Ø§ÛŒØ§Ù† ÙˆÛŒØ²ÛŒØª"""
        
        encounter = await Encounter.objects.get(
            id=encounter_id,
            status='in_progress'
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        encounter.status = 'completed'
        encounter.ended_at = timezone.now()
        await encounter.save()
        
        # ØªÙˆÙ‚Ù Ø¶Ø¨Ø·
        if encounter.is_recording_enabled:
            recording_url = await self._stop_recording(encounter)
            encounter.recording_url = recording_url
            await encounter.save()
            
        # Ø´Ø±ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ø³ Ø§Ø² ÙˆÛŒØ²ÛŒØª
        await self._post_visit_processing(encounter)
        
        return encounter
        
    async def _check_doctor_availability(
        self,
        doctor_id: str,
        scheduled_at: datetime,
        duration_minutes: int
    ) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ø¨ÙˆØ¯Ù† Ù¾Ø²Ø´Ú©"""
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ÛŒ
        doctor_profile = await DoctorProfile.objects.get(user_id=doctor_id)
        working_hours = doctor_profile.working_hours
        
        day_of_week = scheduled_at.strftime('%A').lower()
        if day_of_week not in working_hours:
            return False
            
        time_str = scheduled_at.strftime('%H:%M')
        day_hours = working_hours[day_of_week]
        
        if not (day_hours['start'] <= time_str <= day_hours['end']):
            return False
            
        # Ø¨Ø±Ø±Ø³ÛŒ ØªØ¯Ø§Ø®Ù„ Ø¨Ø§ ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø±
        end_time = scheduled_at + timedelta(minutes=duration_minutes)
        
        conflicts = await Encounter.objects.filter(
            doctor_id=doctor_id,
            status__in=['scheduled', 'confirmed'],
            scheduled_at__lt=end_time,
            scheduled_at__gte=scheduled_at - timedelta(
                minutes=F('duration_minutes')
            )
        ).exists()
        
        return not conflicts
```

### Video Conference Service

```python
# encounters/services/video_service.py
import jwt
from typing import Dict
import aiohttp

class VideoConferenceService:
    """Ø³Ø±ÙˆÛŒØ³ Ú©Ù†ÙØ±Ø§Ù†Ø³ ÙˆÛŒØ¯ÛŒÙˆÛŒÛŒ"""
    
    def __init__(self):
        self.jitsi_domain = settings.JITSI_DOMAIN
        self.jwt_secret = settings.JITSI_JWT_SECRET
        self.turn_servers = settings.TURN_SERVERS
        
    async def create_room(
        self,
        encounter_id: str,
        scheduled_at: datetime,
        duration_minutes: int
    ) -> Dict:
        """Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚ ÙˆÛŒØ¯ÛŒÙˆ"""
        
        room_id = f"helssa-{encounter_id[:8]}"
        
        # ØªÙˆÙ„ÛŒØ¯ JWT Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø¯ÙˆØ¯Ø³Ø§Ø²ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ
        patient_jwt = self._generate_room_jwt(
            room_id,
            'patient',
            duration_minutes
        )
        doctor_jwt = self._generate_room_jwt(
            room_id,
            'doctor',
            duration_minutes,
            is_moderator=True
        )
        
        # URL Ù‡Ø§ÛŒ Ø§ØªØµØ§Ù„
        base_url = f"https://{self.jitsi_domain}/{room_id}"
        
        return {
            'room_id': room_id,
            'patient_url': f"{base_url}?jwt={patient_jwt}",
            'doctor_url': f"{base_url}?jwt={doctor_jwt}",
            'turn_servers': self.turn_servers,
            'expires_at': scheduled_at + timedelta(
                minutes=duration_minutes + 30
            )
        }
        
    def _generate_room_jwt(
        self,
        room_id: str,
        user_type: str,
        duration_minutes: int,
        is_moderator: bool = False
    ) -> str:
        """ØªÙˆÙ„ÛŒØ¯ JWT Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ØªØ§Ù‚"""
        
        now = datetime.utcnow()
        exp = now + timedelta(minutes=duration_minutes + 30)
        
        payload = {
            'aud': 'jitsi',
            'iss': 'helssa',
            'sub': self.jitsi_domain,
            'room': room_id,
            'exp': int(exp.timestamp()),
            'moderator': is_moderator,
            'context': {
                'user': {
                    'name': f"HELSSA {user_type.title()}",
                    'avatar': '',
                    'id': user_type
                },
                'features': {
                    'recording': is_moderator,
                    'livestreaming': False,
                    'transcription': False,
                    'outbound-call': False
                }
            }
        }
        
        return jwt.encode(payload, self.jwt_secret, algorithm='HS256')
        
    async def start_recording(
        self,
        room_id: str,
        encounter_id: str
    ) -> bool:
        """Ø´Ø±ÙˆØ¹ Ø¶Ø¨Ø· ÙˆÛŒØ¯ÛŒÙˆ"""
        
        # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ Jibri
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{settings.JIBRI_URL}/api/record/start",
                json={
                    'room_id': room_id,
                    'session_id': encounter_id,
                    'stream_key': self._generate_stream_key(encounter_id)
                },
                headers={'Authorization': f'Bearer {settings.JIBRI_TOKEN}'}
            ) as response:
                return response.status == 200
                
    async def stop_recording(
        self,
        room_id: str,
        encounter_id: str
    ) -> str:
        """ØªÙˆÙ‚Ù Ø¶Ø¨Ø· Ùˆ Ø¯Ø±ÛŒØ§ÙØª URL"""
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{settings.JIBRI_URL}/api/record/stop",
                json={'room_id': room_id},
                headers={'Authorization': f'Bearer {settings.JIBRI_TOKEN}'}
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    # Ø¢Ù¾Ù„ÙˆØ¯ Ø¨Ù‡ MinIO
                    file_url = await self._upload_recording(
                        data['file_path'],
                        encounter_id
                    )
                    
                    return file_url
                    
        return None
```

## ğŸ™ï¸ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª ÙˆÛŒØ²ÛŒØª

### Audio Processing Service

```python
# encounters/services/audio_processor.py
from pydub import AudioSegment
import asyncio
from typing import List, Dict

class AudioProcessingService:
    """Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙˆØª ÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.storage_service = MinIOStorageService()
        self.encryption_service = EncryptionService()
        self.chunk_size_mb = 10  # Ø­Ø¬Ù… Ù‡Ø± Ù‚Ø·Ø¹Ù‡
        self.overlap_seconds = 2  # Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ Ø¨ÛŒÙ† Ù‚Ø·Ø¹Ø§Øª
        
    async def process_visit_audio(
        self,
        encounter_id: str,
        audio_stream: bytes,
        chunk_index: int
    ) -> AudioChunk:
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© Ù‚Ø·Ø¹Ù‡ ØµÙˆØªÛŒ"""
        
        encounter = await Encounter.objects.get(id=encounter_id)
        
        # Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ ØµÙˆØª
        encrypted_audio = await self.encryption_service.encrypt(
            audio_stream,
            encounter.encryption_key
        )
        
        # Ø¢Ù¾Ù„ÙˆØ¯ Ø¨Ù‡ MinIO
        file_name = f"encounters/{encounter_id}/chunk_{chunk_index:04d}.webm"
        file_url = await self.storage_service.upload(
            file_name,
            encrypted_audio,
            content_type='audio/webm'
        )
        
        # ØªØ­Ù„ÛŒÙ„ ØµÙˆØª
        audio_info = await self._analyze_audio(audio_stream)
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯ AudioChunk
        audio_chunk = await AudioChunk.objects.create(
            encounter=encounter,
            chunk_index=chunk_index,
            file_url=file_url,
            file_size=len(encrypted_audio),
            duration_seconds=audio_info['duration'],
            format='webm',
            sample_rate=audio_info['sample_rate'],
            bit_rate=audio_info['bit_rate'],
            is_encrypted=True,
            encryption_metadata={
                'algorithm': 'AES-256-GCM',
                'key_id': encounter.encryption_key[:8]
            }
        )
        
        # Ø´Ø±ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø²Ø´ STT Ø¯Ø± Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
        asyncio.create_task(
            self._process_stt_async(audio_chunk.id)
        )
        
        return audio_chunk
        
    async def merge_audio_chunks(
        self,
        encounter_id: str
    ) -> str:
        """Ø§Ø¯ØºØ§Ù… Ù‚Ø·Ø¹Ø§Øª ØµÙˆØªÛŒ"""
        
        # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù‡Ù…Ù‡ Ù‚Ø·Ø¹Ø§Øª
        chunks = await AudioChunk.objects.filter(
            encounter_id=encounter_id
        ).order_by('chunk_index')
        
        # Ø¯Ø§Ù†Ù„ÙˆØ¯ Ùˆ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ
        audio_segments = []
        for chunk in chunks:
            encrypted_data = await self.storage_service.download(
                chunk.file_url
            )
            
            decrypted_data = await self.encryption_service.decrypt(
                encrypted_data,
                chunk.encounter.encryption_key
            )
            
            segment = AudioSegment.from_file(
                io.BytesIO(decrypted_data),
                format=chunk.format
            )
            audio_segments.append(segment)
            
        # Ø§Ø¯ØºØ§Ù… Ø¨Ø§ Ø­Ø°Ù Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒâ€ŒÙ‡Ø§
        merged_audio = self._merge_with_overlap_removal(
            audio_segments,
            self.overlap_seconds
        )
        
        # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ ÙØ±Ù…Øª Ù†Ù‡Ø§ÛŒÛŒ
        output_format = 'mp3'
        output_buffer = io.BytesIO()
        merged_audio.export(
            output_buffer,
            format=output_format,
            bitrate='192k'
        )
        
        # Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ùˆ Ø¢Ù¾Ù„ÙˆØ¯
        encounter = await Encounter.objects.get(id=encounter_id)
        encrypted_final = await self.encryption_service.encrypt(
            output_buffer.getvalue(),
            encounter.encryption_key
        )
        
        final_url = await self.storage_service.upload(
            f"encounters/{encounter_id}/full_recording.{output_format}",
            encrypted_final,
            content_type=f'audio/{output_format}'
        )
        
        return final_url
        
    def _merge_with_overlap_removal(
        self,
        segments: List[AudioSegment],
        overlap_seconds: int
    ) -> AudioSegment:
        """Ø§Ø¯ØºØ§Ù… Ø¨Ø§ Ø­Ø°Ù Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†ÛŒ"""
        
        if not segments:
            return AudioSegment.empty()
            
        merged = segments[0]
        overlap_ms = overlap_seconds * 1000
        
        for i in range(1, len(segments)):
            current = segments[i]
            
            # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù†Ù‚Ø·Ù‡ Ø§ØªØµØ§Ù„ Ø¨Ø§ cross-correlation
            overlap_start = len(merged) - overlap_ms
            if overlap_start > 0:
                # Ø­Ø°Ù Ø¨Ø®Ø´ Ù‡Ù…Ù¾ÙˆØ´Ø§Ù†
                merged = merged[:overlap_start] + current[overlap_ms:]
            else:
                merged += current
                
        return merged
        
    async def _analyze_audio(self, audio_data: bytes) -> Dict:
        """ØªØ­Ù„ÛŒÙ„ Ù…Ø´Ø®ØµØ§Øª ØµÙˆØª"""
        
        audio = AudioSegment.from_file(io.BytesIO(audio_data))
        
        return {
            'duration': len(audio) / 1000.0,  # Ø¨Ù‡ Ø«Ø§Ù†ÛŒÙ‡
            'sample_rate': audio.frame_rate,
            'channels': audio.channels,
            'bit_rate': audio.frame_rate * audio.sample_width * 8,
            'format': audio.format
        }
```

### STT Processing Pipeline

```python
# encounters/tasks.py
from celery import shared_task, chain, group
from typing import List

@shared_task(queue='stt')
def process_audio_chunk_stt(chunk_id: str) -> Dict:
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ STT ÛŒÚ© Ù‚Ø·Ø¹Ù‡ ØµÙˆØªÛŒ"""
    
    chunk = AudioChunk.objects.get(id=chunk_id)
    
    # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
    chunk.transcription_status = 'processing'
    chunk.save()
    
    try:
        # Ø¯Ø§Ù†Ù„ÙˆØ¯ Ùˆ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ
        encrypted_audio = download_from_minio(chunk.file_url)
        decrypted_audio = decrypt_audio(
            encrypted_audio,
            chunk.encounter.encryption_key
        )
        
        # ØªØ¨Ø¯ÛŒÙ„ ÙØ±Ù…Øª Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
        if chunk.format != 'mp3':
            converted_audio = convert_audio_format(
                decrypted_audio,
                chunk.format,
                'mp3'
            )
        else:
            converted_audio = decrypted_audio
            
        # Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Whisper
        stt_service = WhisperSTTService()
        result = asyncio.run(
            stt_service.transcribe_audio(
                converted_audio,
                f"chunk_{chunk.chunk_index}.mp3",
                language='fa'
            )
        )
        
        # Ø°Ø®ÛŒØ±Ù‡ Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ
        transcript = Transcript.objects.create(
            audio_chunk=chunk,
            text=result['text'],
            language=result['language'],
            confidence_score=result.get('confidence', 0.8),
            word_timestamps=result.get('segments', []),
            stt_model='whisper-1',
            processing_time=result.get('duration', 0)
        )
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ
        medical_entities = extract_medical_entities.delay(
            transcript.id
        )
        
        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
        chunk.transcription_status = 'completed'
        chunk.is_processed = True
        chunk.processed_at = timezone.now()
        chunk.save()
        
        return {
            'chunk_id': str(chunk.id),
            'transcript_id': str(transcript.id),
            'text_length': len(result['text']),
            'confidence': result.get('confidence', 0)
        }
        
    except Exception as e:
        chunk.transcription_status = 'failed'
        chunk.save()
        
        raise STTProcessingError(f"Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ STT: {str(e)}")

@shared_task
def merge_encounter_transcripts(encounter_id: str) -> str:
    """Ø§Ø¯ØºØ§Ù… Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒâ€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ù…Ù„Ø§Ù‚Ø§Øª"""
    
    # Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ ØªÙ…Ø§Ù… Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒâ€ŒÙ‡Ø§
    transcripts = Transcript.objects.filter(
        audio_chunk__encounter_id=encounter_id
    ).order_by('audio_chunk__chunk_index')
    
    # Ø§Ø¯ØºØ§Ù… Ù…ØªÙ†â€ŒÙ‡Ø§
    full_text = ""
    for transcript in transcripts:
        full_text += transcript.text + " "
        
    # Ø­Ø°Ù ØªÚ©Ø±Ø§Ø±Ù‡Ø§ Ø¯Ø± Ù†Ù‚Ø§Ø· Ø§ØªØµØ§Ù„
    cleaned_text = remove_overlap_duplicates(full_text)
    
    # Ø°Ø®ÛŒØ±Ù‡ Ù…ØªÙ† Ú©Ø§Ù…Ù„
    encounter = Encounter.objects.get(id=encounter_id)
    encounter.metadata['full_transcript'] = cleaned_text
    encounter.metadata['transcript_word_count'] = len(cleaned_text.split())
    encounter.save()
    
    # Ø´Ø±ÙˆØ¹ ØªÙˆÙ„ÛŒØ¯ SOAP
    generate_soap_report.delay(encounter_id)
    
    return cleaned_text

@shared_task(queue='nlp')
def extract_medical_entities(transcript_id: str) -> Dict:
    """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙˆØ¬ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ"""
    
    transcript = Transcript.objects.get(id=transcript_id)
    
    nlp_service = MedicalNLPService()
    entities = asyncio.run(
        nlp_service.extract_medical_entities(transcript.text)
    )
    
    # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ transcript
    transcript.medical_entities = entities['entities']
    transcript.save()
    
    return entities
```

## ğŸ“ ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP

### SOAP Generation Service

```python
# encounters/services/soap_generator.py
from typing import Dict, List, Optional
import asyncio

class SOAPGenerationService:
    """Ø³Ø±ÙˆÛŒØ³ ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP"""
    
    def __init__(self):
        self.ai_service = UnifiedAIService()
        self.template_engine = SOAPTemplateEngine()
        self.validator = SOAPValidator()
        
    async def generate_soap_report(
        self,
        encounter_id: str,
        regenerate: bool = False
    ) -> SOAPReport:
        """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ SOAP Ø§Ø² Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        encounter = await Encounter.objects.select_related(
            'patient', 'doctor'
        ).get(id=encounter_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù‚Ø¨Ù„ÛŒ
        if not regenerate:
            existing_report = await SOAPReport.objects.filter(
                encounter=encounter,
                doctor_approved=True
            ).first()
            
            if existing_report:
                return existing_report
                
        # Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        context = await self._prepare_context(encounter)
        
        # ØªÙˆÙ„ÛŒØ¯ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ SOAP
        soap_sections = await asyncio.gather(
            self._generate_subjective(context),
            self._generate_objective(context),
            self._generate_assessment(context),
            self._generate_plan(context)
        )
        
        # ØªØ±Ú©ÛŒØ¨ Ùˆ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ
        soap_data = {
            'subjective': soap_sections[0],
            'objective': soap_sections[1],
            'assessment': soap_sections[2],
            'plan': soap_sections[3]
        }
        
        # Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ
        validation_result = await self.validator.validate_soap(soap_data)
        if not validation_result['is_valid']:
            # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­ Ø®ÙˆØ¯Ú©Ø§Ø±
            soap_data = await self._auto_correct_soap(
                soap_data,
                validation_result['issues']
            )
            
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³Ø§Ø®ØªØ§Ø±ÛŒØ§ÙØªÙ‡
        structured_data = await self._extract_structured_data(soap_data)
        
        # Ø§ÛŒØ¬Ø§Ø¯ ÛŒØ§ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú¯Ø²Ø§Ø±Ø´
        report, created = await SOAPReport.objects.update_or_create(
            encounter=encounter,
            defaults={
                **soap_data,
                **structured_data,
                'generation_method': 'ai',
                'ai_confidence': validation_result.get('confidence', 0.85)
            }
        )
        
        # ØªÙˆÙ„ÛŒØ¯ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§
        await self._generate_outputs(report)
        
        return report
        
    async def _prepare_context(self, encounter: Encounter) -> Dict:
        """Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ context Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ SOAP"""
        
        # Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ú©Ø§Ù…Ù„
        full_transcript = encounter.metadata.get('full_transcript', '')
        
        # ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù¾Ø²Ø´Ú©ÛŒ Ø¨ÛŒÙ…Ø§Ø±
        patient_history = await self._get_patient_history(
            encounter.patient_id
        )
        
        # Ø¯Ø§Ø±ÙˆÙ‡Ø§ÛŒ ÙØ¹Ù„ÛŒ
        current_medications = await self._get_current_medications(
            encounter.patient_id
        )
        
        # Ù†ØªØ§ÛŒØ¬ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ø§Ø®ÛŒØ±
        recent_labs = await self._get_recent_lab_results(
            encounter.patient_id
        )
        
        return {
            'encounter': encounter,
            'transcript': full_transcript,
            'chief_complaint': encounter.chief_complaint,
            'patient': {
                'age': self._calculate_age(encounter.patient.birth_date),
                'gender': encounter.patient.gender,
                'history': patient_history,
                'medications': current_medications,
                'labs': recent_labs
            },
            'visit_type': encounter.type,
            'duration': encounter.actual_duration.total_seconds() / 60
        }
        
    async def _generate_subjective(self, context: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø¨Ø®Ø´ Subjective"""
        
        prompt = f"""Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ Ø²ÛŒØ±ØŒ Ø¨Ø®Ø´ Subjective Ú¯Ø²Ø§Ø±Ø´ SOAP Ø±Ø§ ØªÙˆÙ„ÛŒØ¯ Ú©Ù†ÛŒØ¯.

Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒÙ…Ø§Ø±:
- Ø³Ù†: {context['patient']['age']} Ø³Ø§Ù„
- Ø¬Ù†Ø³ÛŒØª: {context['patient']['gender']}
- Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ: {context['chief_complaint']}

Ø±ÙˆÙ†ÙˆÛŒØ³ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª:
{context['transcript'][:3000]}  # Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡ 3000 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø§ÙˆÙ„

Ø¨Ø®Ø´ Subjective Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ Ù…ÙˆØ§Ø±Ø¯ Ø²ÛŒØ± Ø¨Ø§Ø´Ø¯:
1. Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ (Chief Complaint - CC)
2. ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø¨ÛŒÙ…Ø§Ø±ÛŒ ÙØ¹Ù„ÛŒ (History of Present Illness - HPI) Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª OLDCARTS
3. Ø³Ø§Ø¨Ù‚Ù‡ Ù¾Ø²Ø´Ú©ÛŒ (Past Medical History - PMH)
4. Ø¯Ø§Ø±ÙˆÙ‡Ø§ÛŒ Ù…ØµØ±ÙÛŒ (Medications)
5. Ø¢Ù„Ø±Ú˜ÛŒâ€ŒÙ‡Ø§ (Allergies)
6. Ø³Ø§Ø¨Ù‚Ù‡ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ (Social History) Ø¯Ø± ØµÙˆØ±Øª Ø§Ø±ØªØ¨Ø§Ø·
7. Ø³Ø§Ø¨Ù‚Ù‡ Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ (Family History) Ø¯Ø± ØµÙˆØ±Øª Ø°Ú©Ø±

ÙÙ‚Ø· Ø¨Ø®Ø´ Subjective Ø±Ø§ Ø¨Ù‡ ÙØ§Ø±Ø³ÛŒ Ùˆ Ø¨Ø§ ÙØ±Ù…Øª Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ù¾Ø²Ø´Ú©ÛŒ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯."""

        response = await self.ai_service.generate_text(
            prompt,
            model='gpt-4',
            temperature=0.3,
            max_tokens=1500
        )
        
        return response['text']
        
    async def _generate_objective(self, context: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø¨Ø®Ø´ Objective"""
        
        # Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹ÛŒÙ†ÛŒ
        vital_signs = await self._extract_vital_signs(context['transcript'])
        exam_findings = await self._extract_exam_findings(context['transcript'])
        
        prompt = f"""Ø¨Ø®Ø´ Objective Ú¯Ø²Ø§Ø±Ø´ SOAP Ø±Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø²ÛŒØ± ØªÙˆÙ„ÛŒØ¯ Ú©Ù†ÛŒØ¯:

Ø¹Ù„Ø§Ø¦Ù… Ø­ÛŒØ§ØªÛŒ ÛŒØ§ÙØª Ø´Ø¯Ù‡:
{vital_signs}

ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§ÛŒÙ†Ù‡:
{exam_findings}

Ù†ØªØ§ÛŒØ¬ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ø§Ø®ÛŒØ±:
{context['patient']['labs']}

Ø¨Ø®Ø´ Objective Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„:
1. Ø¹Ù„Ø§Ø¦Ù… Ø­ÛŒØ§ØªÛŒ (Vital Signs)
2. Ø¸Ø§Ù‡Ø± Ø¹Ù…ÙˆÙ…ÛŒ (General Appearance)
3. ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§ÛŒÙ†Ù‡ ÙÛŒØ²ÛŒÚ©ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒÚ©
4. Ù†ØªØ§ÛŒØ¬ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ùˆ ØªØµÙˆÛŒØ±Ø¨Ø±Ø¯Ø§Ø±ÛŒ

ÙÙ‚Ø· ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ Ø¹ÛŒÙ†ÛŒ Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø±Ø§ Ø°Ú©Ø± Ú©Ù†ÛŒØ¯."""

        response = await self.ai_service.generate_text(
            prompt,
            model='gpt-4',
            temperature=0.2,
            max_tokens=1000
        )
        
        return response['text']
        
    async def _generate_assessment(self, context: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø¨Ø®Ø´ Assessment"""
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ
        possible_diagnoses = await self._extract_diagnoses(
            context['transcript']
        )
        
        prompt = f"""Ø¨Ø®Ø´ Assessment Ú¯Ø²Ø§Ø±Ø´ SOAP Ø±Ø§ ØªÙˆÙ„ÛŒØ¯ Ú©Ù†ÛŒØ¯.

Ø¨Ø± Ø§Ø³Ø§Ø³:
- Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ: {context['chief_complaint']}
- ÛŒØ§ÙØªÙ‡â€ŒÙ‡Ø§ÛŒ subjective Ùˆ objective
- ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ Ù…Ø·Ø±Ø­ Ø´Ø¯Ù‡: {possible_diagnoses}

Assessment Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„:
1. Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ Ø§Ø² ÙˆØ¶Ø¹ÛŒØª Ø¨ÛŒÙ…Ø§Ø±
2. ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ø§Ø­ØªÙ…Ø§Ù„
3. ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ÛŒ Ø§ÙØªØ±Ø§Ù‚ÛŒ Ù…Ù‡Ù…
4. Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯Øª Ùˆ Ù¾ÛŒØ´â€ŒØ¢Ú¯Ù‡ÛŒ

Ø§Ø² Ø§ØµØ·Ù„Ø§Ø­Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ùˆ Ú©Ø¯Ù‡Ø§ÛŒ ICD-10 Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."""

        response = await self.ai_service.generate_text(
            prompt,
            model='gpt-4',
            temperature=0.3,
            max_tokens=800
        )
        
        return response['text']
        
    async def _generate_plan(self, context: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø¨Ø®Ø´ Plan"""
        
        prompt = f"""Ø¨Ø®Ø´ Plan Ú¯Ø²Ø§Ø±Ø´ SOAP Ø±Ø§ ØªÙˆÙ„ÛŒØ¯ Ú©Ù†ÛŒØ¯.

Plan Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ Ù…ÙˆØ§Ø±Ø¯ Ø²ÛŒØ± Ø¨Ù‡ ØµÙˆØ±Øª Ø´Ù…Ø§Ø±Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯:
1. Ø¯Ø±Ù…Ø§Ù† Ø¯Ø§Ø±ÙˆÛŒÛŒ (Ø¨Ø§ Ø°Ú©Ø± Ø¯ÙˆØ²ØŒ Ø±ÙˆØ´ Ù…ØµØ±Ù Ùˆ Ù…Ø¯Øª)
2. Ø¯Ø±Ù…Ø§Ù†â€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ø¯Ø§Ø±ÙˆÛŒÛŒ
3. Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ùˆ ØªØµÙˆÛŒØ±Ø¨Ø±Ø¯Ø§Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ
4. Ø§Ø±Ø¬Ø§Ø¹Ø§Øª ØªØ®ØµØµÛŒ Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
5. Ø¢Ù…ÙˆØ²Ø´ Ø¨ÛŒÙ…Ø§Ø±
6. Ø²Ù…Ø§Ù† Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø¨Ø¹Ø¯ÛŒ
7. Ø¹Ù„Ø§Ø¦Ù… Ù‡Ø´Ø¯Ø§Ø±Ø¯Ù‡Ù†Ø¯Ù‡ Ú©Ù‡ Ø¨ÛŒÙ…Ø§Ø± Ø¨Ø§ÛŒØ¯ Ù…Ø±Ø§Ø¬Ø¹Ù‡ ÙÙˆØ±ÛŒ Ú©Ù†Ø¯

Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø±ÙˆÙ‡Ø§ Ø§Ø² Ù†Ø§Ù… Ú˜Ù†Ø±ÛŒÚ© Ùˆ Ø¯ÙˆØ² Ø¯Ù‚ÛŒÙ‚ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."""

        response = await self.ai_service.generate_text(
            prompt,
            model='gpt-4',
            temperature=0.3,
            max_tokens=1000
        )
        
        return response['text']
        
    async def _extract_structured_data(self, soap_data: Dict) -> Dict:
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³Ø§Ø®ØªØ§Ø±ÛŒØ§ÙØªÙ‡ Ø§Ø² SOAP"""
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªØ´Ø®ÛŒØµâ€ŒÙ‡Ø§ Ø¨Ø§ Ú©Ø¯ ICD
        diagnoses = await self._extract_icd_codes(soap_data['assessment'])
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø±ÙˆÙ‡Ø§
        medications = await self._parse_medications(soap_data['plan'])
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª
        lab_orders = await self._parse_lab_orders(soap_data['plan'])
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ
        follow_up = await self._parse_follow_up(soap_data['plan'])
        
        return {
            'diagnoses': diagnoses,
            'medications': medications,
            'lab_orders': lab_orders,
            'follow_up': follow_up
        }
```

### SOAP Output Generator

```python
# encounters/services/output_generator.py
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
import markdown2
from typing import Dict

class SOAPOutputGenerator:
    """ØªÙˆÙ„ÛŒØ¯Ú©Ù†Ù†Ø¯Ù‡ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ú¯Ø²Ø§Ø±Ø´ SOAP"""
    
    def __init__(self):
        self.storage_service = MinIOStorageService()
        self.pdf_styles = self._setup_pdf_styles()
        
    async def generate_pdf(self, report: SOAPReport) -> str:
        """ØªÙˆÙ„ÛŒØ¯ PDF Ø§Ø² Ú¯Ø²Ø§Ø±Ø´ SOAP"""
        
        # Ø§ÛŒØ¬Ø§Ø¯ buffer
        buffer = io.BytesIO()
        
        # Ø§ÛŒØ¬Ø§Ø¯ document
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18,
        )
        
        # Ù…Ø­ØªÙˆØ§ÛŒ PDF
        story = []
        
        # Ù‡Ø¯Ø±
        story.extend(self._create_header(report))
        
        # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒÙ…Ø§Ø± Ùˆ ÙˆÛŒØ²ÛŒØª
        story.extend(self._create_visit_info(report))
        
        # Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ SOAP
        story.extend(self._create_soap_sections(report))
        
        # Ù†Ø³Ø®Ù‡ Ùˆ Ø¯Ø³ØªÙˆØ±Ø§Øª
        if report.medications:
            story.extend(self._create_prescription(report))
            
        # Ø§Ù…Ø¶Ø§
        story.extend(self._create_signature_section(report))
        
        # Ø³Ø§Ø®Øª PDF
        doc.build(story)
        
        # Ø¢Ù¾Ù„ÙˆØ¯ Ø¨Ù‡ storage
        pdf_bytes = buffer.getvalue()
        buffer.close()
        
        file_name = f"reports/{report.encounter_id}/soap_report.pdf"
        pdf_url = await self.storage_service.upload(
            file_name,
            pdf_bytes,
            content_type='application/pdf'
        )
        
        return pdf_url
        
    async def generate_markdown(self, report: SOAPReport) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Markdown Ø§Ø² Ú¯Ø²Ø§Ø±Ø´ SOAP"""
        
        encounter = report.encounter
        patient = encounter.patient
        doctor = encounter.doctor
        
        markdown_content = f"""# Ú¯Ø²Ø§Ø±Ø´ Ù…Ù„Ø§Ù‚Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ

## Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆÛŒØ²ÛŒØª
- **ØªØ§Ø±ÛŒØ®**: {encounter.scheduled_at.strftime('%Y/%m/%d')}
- **Ø³Ø§Ø¹Øª**: {encounter.scheduled_at.strftime('%H:%M')}
- **Ù†ÙˆØ¹ ÙˆÛŒØ²ÛŒØª**: {encounter.get_type_display()}
- **Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: {encounter.actual_duration.total_seconds() / 60:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡

## Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒÙ…Ø§Ø±
- **Ù†Ø§Ù…**: {patient.first_name} {patient.last_name}
- **Ø³Ù†**: {self._calculate_age(patient.birth_date)} Ø³Ø§Ù„
- **Ø¬Ù†Ø³ÛŒØª**: {patient.get_gender_display()}
- **Ø´Ù…Ø§Ø±Ù‡ Ù¾Ø±ÙˆÙ†Ø¯Ù‡**: {patient.patient_profile.medical_record_number}

## Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø²Ø´Ú©
- **Ù†Ø§Ù…**: Ø¯Ú©ØªØ± {doctor.first_name} {doctor.last_name}
- **ØªØ®ØµØµ**: {doctor.doctor_profile.specialty}
- **Ø´Ù…Ø§Ø±Ù‡ Ù†Ø¸Ø§Ù… Ù¾Ø²Ø´Ú©ÛŒ**: {doctor.doctor_profile.medical_council_number}

## Ø´Ú©Ø§ÛŒØª Ø§ØµÙ„ÛŒ
{encounter.chief_complaint}

## Ú¯Ø²Ø§Ø±Ø´ SOAP

### Subjective (Ø´Ø±Ø­ Ø­Ø§Ù„)
{report.subjective}

### Objective (Ù…Ø¹Ø§ÛŒÙ†Ù‡)
{report.objective}

### Assessment (Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ)
{report.assessment}

### Plan (Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¯Ø±Ù…Ø§Ù†)
{report.plan}

"""

        # Ø§ÙØ²ÙˆØ¯Ù† Ù†Ø³Ø®Ù‡ Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯
        if report.medications:
            markdown_content += "\n## Ù†Ø³Ø®Ù‡ Ù¾Ø²Ø´Ú©ÛŒ\n\n"
            for i, med in enumerate(report.medications, 1):
                markdown_content += f"{i}. **{med['name']}**\n"
                markdown_content += f"   - Ø¯ÙˆØ²: {med['dosage']}\n"
                markdown_content += f"   - Ø±ÙˆØ´ Ù…ØµØ±Ù: {med['route']}\n"
                markdown_content += f"   - ØªØ¹Ø¯Ø§Ø¯/Ù…Ø¯Øª: {med['duration']}\n\n"
                
        # Ø§ÙØ²ÙˆØ¯Ù† Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯
        if report.lab_orders:
            markdown_content += "\n## Ø¢Ø²Ù…Ø§ÛŒØ´Ø§Øª Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ\n\n"
            for lab in report.lab_orders:
                markdown_content += f"- {lab['name']}\n"
                
        # Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ
        if report.follow_up:
            markdown_content += f"\n## Ù¾ÛŒÚ¯ÛŒØ±ÛŒ\n"
            markdown_content += f"- **Ø²Ù…Ø§Ù†**: {report.follow_up.get('date', 'Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ')}\n"
            markdown_content += f"- **Ø¯Ù„ÛŒÙ„**: {report.follow_up.get('reason', 'Ú©Ù†ØªØ±Ù„ Ø¯Ø±Ù…Ø§Ù†')}\n"
            
        # Ø§Ù…Ø¶Ø§
        if report.doctor_approved:
            markdown_content += f"\n---\n"
            markdown_content += f"**ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø·**: Ø¯Ú©ØªØ± {doctor.first_name} {doctor.last_name}\n"
            markdown_content += f"**ØªØ§Ø±ÛŒØ® ØªØ§ÛŒÛŒØ¯**: {report.doctor_approved_at.strftime('%Y/%m/%d %H:%M')}\n"
            
        return markdown_content
        
    def _create_header(self, report: SOAPReport) -> List:
        """Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ø¯Ø± PDF"""
        
        styles = self.pdf_styles
        story = []
        
        # Ù„ÙˆÚ¯Ùˆ Ùˆ Ø¹Ù†ÙˆØ§Ù†
        header_data = [
            [
                Paragraph("HELSSA", styles['Title']),
                Paragraph("Ú¯Ø²Ø§Ø±Ø´ Ù…Ù„Ø§Ù‚Ø§Øª Ù¾Ø²Ø´Ú©ÛŒ", styles['Title'])
            ]
        ]
        
        header_table = Table(header_data, colWidths=[3*inch, 3*inch])
        header_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('FONTSIZE', (0, 0), (-1, -1), 16),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ]))
        
        story.append(header_table)
        story.append(Spacer(1, 0.25*inch))
        
        return story
```

## ğŸ“ Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§

### File Management Service

```python
# encounters/services/file_manager.py
from typing import List, Dict, Optional
import hashlib
import magic

class EncounterFileManager:
    """Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª"""
    
    def __init__(self):
        self.storage = MinIOStorageService()
        self.encryption = EncryptionService()
        self.allowed_types = {
            'audio': ['audio/mpeg', 'audio/wav', 'audio/webm', 'audio/ogg'],
            'image': ['image/jpeg', 'image/png', 'image/gif'],
            'document': ['application/pdf', 'application/msword'],
            'video': ['video/mp4', 'video/webm']
        }
        
    async def upload_encounter_file(
        self,
        encounter_id: str,
        file_data: bytes,
        file_name: str,
        file_type: str,
        uploaded_by: str
    ) -> EncounterFile:
        """Ø¢Ù¾Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        encounter = await Encounter.objects.get(id=encounter_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
        mime_type = magic.from_buffer(file_data, mime=True)
        if not self._is_allowed_file_type(mime_type, file_type):
            raise InvalidFileTypeError(
                f"Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ {mime_type} Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª"
            )
            
        # Ø§Ø³Ú©Ù† Ø§Ù…Ù†ÛŒØªÛŒ
        if not await self._scan_file_security(file_data):
            raise SecurityError("ÙØ§ÛŒÙ„ Ø§Ø² Ù†Ø¸Ø± Ø§Ù…Ù†ÛŒØªÛŒ Ù…Ø´Ú©Ù„ Ø¯Ø§Ø±Ø¯")
            
        # Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ
        encrypted_data = await self.encryption.encrypt(
            file_data,
            encounter.encryption_key
        )
        
        # ØªÙˆÙ„ÛŒØ¯ hash Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ ØªÚ©Ø±Ø§Ø±ÛŒ
        file_hash = hashlib.sha256(file_data).hexdigest()
        
        # Ø¨Ø±Ø±Ø³ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨ÙˆØ¯Ù†
        existing = await EncounterFile.objects.filter(
            encounter=encounter,
            file_hash=file_hash
        ).first()
        
        if existing:
            return existing
            
        # Ø¢Ù¾Ù„ÙˆØ¯ Ø¨Ù‡ storage
        storage_path = f"encounters/{encounter_id}/files/{file_type}/{file_name}"
        file_url = await self.storage.upload(
            storage_path,
            encrypted_data,
            content_type=mime_type
        )
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯
        encounter_file = await EncounterFile.objects.create(
            encounter=encounter,
            file_name=file_name,
            file_type=file_type,
            mime_type=mime_type,
            file_url=file_url,
            file_size=len(file_data),
            file_hash=file_hash,
            uploaded_by_id=uploaded_by,
            is_encrypted=True,
            metadata={
                'original_name': file_name,
                'upload_ip': self._get_client_ip(),
                'user_agent': self._get_user_agent()
            }
        )
        
        return encounter_file
        
    async def get_encounter_files(
        self,
        encounter_id: str,
        file_type: Optional[str] = None,
        user_id: str = None
    ) -> List[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        encounter = await Encounter.objects.get(id=encounter_id)
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ
        if user_id:
            has_access = await self._check_file_access(
                encounter, user_id
            )
            if not has_access:
                raise PermissionDenied("Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯")
                
        # Query files
        query = EncounterFile.objects.filter(encounter=encounter)
        if file_type:
            query = query.filter(file_type=file_type)
            
        files = await query.order_by('-created_at')
        
        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´
        result = []
        for file in files:
            # ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒÙ†Ú© Ù…ÙˆÙ‚Øª Ø¯Ø§Ù†Ù„ÙˆØ¯
            download_url = await self._generate_download_url(
                file, user_id
            )
            
            result.append({
                'id': str(file.id),
                'name': file.file_name,
                'type': file.file_type,
                'mime_type': file.mime_type,
                'size': file.file_size,
                'download_url': download_url,
                'uploaded_at': file.created_at.isoformat(),
                'uploaded_by': file.uploaded_by.get_full_name()
            })
            
        return result
        
    async def _generate_download_url(
        self,
        file: EncounterFile,
        user_id: str
    ) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒÙ†Ú© Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù…ÙˆÙ‚Øª"""
        
        # ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† Ø¯Ø§Ù†Ù„ÙˆØ¯
        token_data = {
            'file_id': str(file.id),
            'user_id': user_id,
            'expires': (datetime.utcnow() + timedelta(hours=1)).isoformat()
        }
        
        token = jwt.encode(
            token_data,
            settings.SECRET_KEY,
            algorithm='HS256'
        )
        
        return f"{settings.BASE_URL}/api/encounters/files/download/?token={token}"
```

## ğŸ” Ø§Ù…Ù†ÛŒØª Ùˆ Ø­Ø±ÛŒÙ… Ø®ØµÙˆØµÛŒ

### Encounter Security Service

```python
# encounters/services/security_service.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

class EncounterSecurityService:
    """Ø³Ø±ÙˆÛŒØ³ Ø§Ù…Ù†ÛŒØª Ù…Ù„Ø§Ù‚Ø§Øªâ€ŒÙ‡Ø§"""
    
    def __init__(self):
        self.access_manager = AccessManager()
        self.audit_logger = AuditLogger()
        
    async def check_encounter_access(
        self,
        user_id: str,
        encounter_id: str,
        action: str = 'view'
    ) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        encounter = await Encounter.objects.get(id=encounter_id)
        user = await UnifiedUser.objects.get(id=user_id)
        
        # Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
        # Ø¨ÛŒÙ…Ø§Ø± Ùˆ Ù¾Ø²Ø´Ú© Ù‡Ù…ÛŒØ´Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø±Ù†Ø¯
        if str(encounter.patient_id) == user_id:
            allowed_actions = ['view', 'download']
            return action in allowed_actions
            
        if str(encounter.doctor_id) == user_id:
            return True  # Ù¾Ø²Ø´Ú© Ø¯Ø³ØªØ±Ø³ÛŒ Ú©Ø§Ù…Ù„ Ø¯Ø§Ø±Ø¯
            
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ù…ÙˆÙ‚Øª
        temp_access = await self.access_manager.check_temporary_access(
            doctor_id=user_id,
            patient_id=str(encounter.patient_id),
            resource='encounter',
            action=action
        )
        
        if temp_access:
            # Ø«Ø¨Øª Ø¯Ø± audit log
            await self.audit_logger.log_access(
                user_id=user_id,
                resource_type='encounter',
                resource_id=encounter_id,
                action=action,
                granted=True,
                reason='temporary_access'
            )
            return True
            
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ
        if user.user_type == 'admin':
            return action in ['view', 'audit']
            
        return False
        
    def generate_encryption_key(self) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        # ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ ØªØµØ§Ø¯ÙÛŒ
        key = Fernet.generate_key()
        return base64.urlsafe_b64encode(key).decode()
        
    async def encrypt_sensitive_data(
        self,
        data: str,
        encryption_key: str
    ) -> str:
        """Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³"""
        
        # Ø§ÛŒØ¬Ø§Ø¯ Fernet cipher
        key = base64.urlsafe_b64decode(encryption_key.encode())
        cipher = Fernet(key)
        
        # Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ
        encrypted = cipher.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted).decode()
        
    async def decrypt_sensitive_data(
        self,
        encrypted_data: str,
        encryption_key: str
    ) -> str:
        """Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³"""
        
        # Ø§ÛŒØ¬Ø§Ø¯ Fernet cipher
        key = base64.urlsafe_b64decode(encryption_key.encode())
        cipher = Fernet(key)
        
        # Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted = cipher.decrypt(encrypted_bytes)
        return decrypted.decode()
        
    async def anonymize_encounter_data(
        self,
        encounter_id: str
    ) -> Dict:
        """Ù†Ø§Ø´Ù†Ø§Ø³â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù„Ø§Ù‚Ø§Øª Ø¨Ø±Ø§ÛŒ ØªØ­Ù‚ÛŒÙ‚Ø§Øª"""
        
        encounter = await Encounter.objects.get(id=encounter_id)
        
        # Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø³ Ø´Ø¯Ù‡
        anonymized = {
            'id': hashlib.sha256(str(encounter.id).encode()).hexdigest()[:16],
            'patient_age': self._calculate_age(encounter.patient.birth_date),
            'patient_gender': encounter.patient.gender,
            'visit_type': encounter.type,
            'duration_minutes': encounter.duration_minutes,
            'chief_complaint_category': self._categorize_complaint(
                encounter.chief_complaint
            )
        }
        
        # Ú¯Ø²Ø§Ø±Ø´ SOAP Ù†Ø§Ø´Ù†Ø§Ø³
        if hasattr(encounter, 'soap_report'):
            report = encounter.soap_report
            anonymized['diagnoses'] = [
                d['icd_code'] for d in report.diagnoses
            ]
            anonymized['medication_count'] = len(report.medications)
            anonymized['lab_order_count'] = len(report.lab_orders)
            
        return anonymized
        
    async def audit_encounter_access(
        self,
        encounter_id: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Dict]:
        """Ú¯Ø²Ø§Ø±Ø´ Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§ Ø¨Ù‡ Ù…Ù„Ø§Ù‚Ø§Øª"""
        
        query = AuditLog.objects.filter(
            resource_type='encounter',
            resource_id=encounter_id
        )
        
        if start_date:
            query = query.filter(created_at__gte=start_date)
        if end_date:
            query = query.filter(created_at__lte=end_date)
            
        logs = await query.order_by('-created_at')
        
        return [
            {
                'user': log.user.get_full_name(),
                'action': log.action,
                'timestamp': log.created_at.isoformat(),
                'ip_address': log.ip_address,
                'user_agent': log.user_agent,
                'granted': log.granted
            }
            for log in logs
        ]
```

---

[ELEMENT: div align="center"]

[â†’ Ù‚Ø¨Ù„ÛŒ: Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ Ùˆ Ø§Ø´ØªØ±Ø§Ú©](07-billing-system.md) | [Ø¨Ø¹Ø¯ÛŒ: Ø¯Ø³ØªØ±Ø³ÛŒ Ù¾Ø²Ø´Ú© Ø¨Ù‡ Ø¨ÛŒÙ…Ø§Ø± â†](09-doctor-access.md)

</div>
